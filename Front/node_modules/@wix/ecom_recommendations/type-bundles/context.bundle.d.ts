type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface Recommendation {
    /** Recommended items. */
    items?: CatalogReference[];
    /** The algorithm used to provide the recommendation. */
    algorithm?: Algorithm;
}
/** Used for grouping line items. Sent when an item is added to a cart, checkout, or order. */
interface CatalogReference {
    /** ID of the item within the catalog it belongs to. */
    catalogItemId?: string;
    /**
     * ID of the app providing the catalog.
     *
     * You can get your app's ID from its page in the [app dashboard](https://dev.wix.com/dc3/my-apps/).
     *
     * For items from Wix catalogs, the following values always apply:
     * + Wix Stores: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`
     * + Wix Bookings: `"13d21c63-b5ec-5912-8397-c3a5ddb27a97"`
     * + Wix Restaurants: `"9a5d83fd-8570-482e-81ab-cfa88942ee60"`
     */
    appId?: string;
    /**
     * Additional item details in key:value pairs. Use this optional field to provide more specificity with item selection. The `options` field values differ depending on which catalog is providing the items.
     *
     * For products and variants from a Wix Stores catalog, learn more about [eCommerce integration](https://dev.wix.com/docs/rest/business-solutions/stores/catalog/e-commerce-integration).
     */
    options?: Record<string, any> | null;
}
interface Algorithm {
    /** Algorithm ID defined by the app providing the algorithm. */
    _id?: string;
    /**
     * App ID of the Wix or 3rd-party app providing the algorithm.
     *
     * Wix app IDs are <a href="https://dev.wix.com/api/rest/getting-started/wix-business-solutions#getting-started_wix-business-solutions_about-wix-business-solutions" target="_blank">listed here</a>.
     */
    appId?: string;
}
interface ListAvailableAlgorithmsRequest {
}
interface ListAvailableAlgorithmsResponse {
    /** Algorithms available for use on your Wix site or project. See the method description for more information. */
    availableAlgorithms?: AlgorithmInfo[];
}
interface AlgorithmInfo {
    /** How the algorithm is configured. */
    config?: AlgorithmConfig;
    /**
     * The app ID of the application providing the algorithm.
     *
     * Wix app IDs are <a href="https://dev.wix.com/api/rest/getting-started/wix-business-solutions#getting-started_wix-business-solutions_about-wix-business-solutions" target="_blank">listed here</a>.
     */
    appId?: string;
    /**
     * App IDs of catalogs to which the algorithm can be applied.
     *
     * Wix app IDs are <a href="https://dev.wix.com/api/rest/getting-started/wix-business-solutions#getting-started_wix-business-solutions_about-wix-business-solutions" target="_blank">listed here</a>.
     */
    catalogAppIds?: string[];
}
interface AlgorithmConfig {
    /** Algorithm name. This value is not translatable. */
    name?: string;
    /** Algorithm description. This describes how the algorithm works and if it has any limitations regarding site content, number of items in the catalog, site traffic, and so on. This value is not translatable. */
    description?: string;
    /** A supplemental `description`. It can be used to help break up and organize information. You can, for example, display this information as a tooltip or as an additional section that is collapsed by default. */
    additionalInfo?: string | null;
    /**
     * Algorithms may have the following types:
     * * `RELATED_ITEMS` - This type of algorithm provides recommendations based on 1 or more other provided items. For example, when an item is added to a cart, the algorithm can suggest other items frequently bought together with that item.
     * * `GLOBAL` - This type of algorithm provides general recommendations based on site or project statistics. For example, bestsellers or new arrivals.
     */
    algorithmType?: AlgorithmType;
    /** Algorithm ID. This must be unique for a specific app but does not have to be unique across all apps on the site or in the project. */
    algorithmId?: string;
}
declare enum AlgorithmType {
    UNSPECIFIED = "UNSPECIFIED",
    RELATED_ITEMS = "RELATED_ITEMS",
    GLOBAL = "GLOBAL"
}
interface GetRecommendationRequest {
    /** The set of items for which to get recommendations. Required if the `algorithmType` is `RELATED_ITEMS`. */
    items?: CatalogReference[];
    /**
     * A list of algorithms checked in a specific order determined by their `appID` and their position in the `algorithms` array.
     * See the method description for more information.
     *
     * If no algorithm is able to return at least `minimumRecommendedItems` items, an empty array is returned.
     */
    algorithms: Algorithm[];
    /**
     * The minimum number of items that must be recommended by the algorithm for those items to be returned in the response.
     *
     * Max: `100`
     */
    minimumRecommendedItems?: number;
}
interface GetRecommendationResponse {
    /** An object containing a list of items recommended by 1 of the specified algorithms. The recommendation is empty if none of the specified algorithms recommended enough items. */
    recommendation?: Recommendation;
}
interface ItemAppIdNotSupportedByProvider {
    /** Items with an App ID not supported by the provider. Supported App IDs can be found in the provider config in the Dev Center. */
    items?: CatalogReference[];
    /** Algorithms that don't support the requested items. */
    algorithms?: Algorithm[];
}
interface RecommendationAlgorithmNotSupported {
    /** Algorithms not supported by the provider. */
    unsupportedAlgorithms?: Algorithm[];
}
interface AlgorithmConfigNonNullableFields {
    name: string;
    description: string;
    algorithmType: AlgorithmType;
    algorithmId: string;
}
interface AlgorithmInfoNonNullableFields {
    config?: AlgorithmConfigNonNullableFields;
    appId: string;
    catalogAppIds: string[];
}
interface ListAvailableAlgorithmsResponseNonNullableFields {
    availableAlgorithms: AlgorithmInfoNonNullableFields[];
}
interface CatalogReferenceNonNullableFields {
    catalogItemId: string;
    appId: string;
}
interface AlgorithmNonNullableFields {
    _id: string;
    appId: string;
}
interface RecommendationNonNullableFields {
    items: CatalogReferenceNonNullableFields[];
    algorithm?: AlgorithmNonNullableFields;
}
interface GetRecommendationResponseNonNullableFields {
    recommendation?: RecommendationNonNullableFields;
}
interface GetRecommendationOptions {
    /** The set of items for which to get recommendations. Required if the `algorithmType` is `RELATED_ITEMS`. */
    items?: CatalogReference[];
    /**
     * The minimum number of items that must be recommended by the algorithm for those items to be returned in the response.
     *
     * Max: `100`
     */
    minimumRecommendedItems?: number;
}

declare function listAvailableAlgorithms$1(httpClient: HttpClient): ListAvailableAlgorithmsSignature;
interface ListAvailableAlgorithmsSignature {
    /**
     * Returns a list of recommendation algorithms that can be used on your Wix site or project. These algorithms can be used with [`getRecommendation()`](#getRecommendation) to provide item recommendations to the customer.
     *
     * Algorithms are run by the apps that provide them, and can only be used on catalogs they support. Apps may provide algorithms for use with their own catalogs and/or catalogs from other apps.
     *
     * The app which provides an algorithm is referenced by that algorithm’s `appId`. The apps whose catalogs are supported by an algorithm are referenced by the IDs in that algorithm’s `catalogAppIds` array.
     *
     *
     * For an algorithm to be considered “Available” and returned in this method’s response, the algorithm must meet the following conditions:
     * 1. The algorithm’s `appId` must match the ID of an installed Wix app.
     * 2. At least 1 of the IDs in `catalogAppIds` must match the ID of an installed Wix app.
     *
     * Wix app IDs are [listed here](https://dev.wix.com/api/rest/getting-started/wix-business-solutions#getting-started_wix-business-solutions_about-wix-business-solutions).
     */
    (): Promise<ListAvailableAlgorithmsResponse & ListAvailableAlgorithmsResponseNonNullableFields>;
}
declare function getRecommendation$1(httpClient: HttpClient): GetRecommendationSignature;
interface GetRecommendationSignature {
    /**
     * Returns a recommendation object containing a list of items to recommend to the customer.
     *
     * `getRecommendation()` determines which items to recommend based on the given recommendation algorithms.
     *
     * `getRecommendation()` doesn’t run the algorithms. It calls the installed apps that provide them.
     *
     * Apps may provide algorithms for use with their own catalogs, or for use with catalogs from other apps.
     * For example, Wix Stores provides algorithms that can only be used on its own catalogs.
     * To run an algorithm, the app providing it must be installed, and an app providing a supported catalog must be installed.
     * For more information and to see which algorithms are available on your site or project, call [`listAvailableAlgorithms()`](#listavailablealgorithms).
     *
     * `getRecommendation()` operates as follows:
     * 1. `getRecommendation()` receives as input a list of algorithms as an array. These algorithms can be provided by different apps and can apply to different catalogs.
     * 2. `getRecommendation()` calls the app that corresponds to the `appId` of the first algorithm in the list of algorithms. It passes that algorithm’s ID and the IDs of any subsequent algorithms in the array for the same app.
     * 3. The app runs the algorithms.
     * 4. `getRecommendation()` returns items recommendations from the first algorithm (according to its position in the `algorithms` array) that meets the minimum number of recommendations. At that point `getRecommendation()` stops calling other apps.
     * 5. If none of the algorithms run by the first app meet the minimum recommended items, `getRecommendation()` finds the next algorithm in the array with a new `appId` (an ID of an app that has not yet been called), and repeats the process.
     * 6. If no algorithms in the `algorithms` array recommend at least the minimum recommended items, `getRecommendation()` returns an empty array.
     * @param - A list of algorithms checked in a specific order determined by their `appID` and their position in the `algorithms` array.
     * See the method description for more information.
     *
     * If no algorithm is able to return at least `minimumRecommendedItems` items, an empty array is returned.
     * @param - Get recommendation options.
     */
    (algorithms: Algorithm[], options?: GetRecommendationOptions | undefined): Promise<GetRecommendationResponse & GetRecommendationResponseNonNullableFields>;
}

declare const listAvailableAlgorithms: MaybeContext<BuildRESTFunction<typeof listAvailableAlgorithms$1> & typeof listAvailableAlgorithms$1>;
declare const getRecommendation: MaybeContext<BuildRESTFunction<typeof getRecommendation$1> & typeof getRecommendation$1>;

export { type Algorithm, type AlgorithmConfig, type AlgorithmInfo, AlgorithmType, type CatalogReference, type GetRecommendationOptions, type GetRecommendationRequest, type GetRecommendationResponse, type GetRecommendationResponseNonNullableFields, type ItemAppIdNotSupportedByProvider, type ListAvailableAlgorithmsRequest, type ListAvailableAlgorithmsResponse, type ListAvailableAlgorithmsResponseNonNullableFields, type Recommendation, type RecommendationAlgorithmNotSupported, getRecommendation, listAvailableAlgorithms };
