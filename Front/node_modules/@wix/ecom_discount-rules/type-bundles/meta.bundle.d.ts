interface DiscountRule$1 {
    /**
     * Discount rule ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /** Discount rule name. */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger$1;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo$1;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts$1;
    /**
     * Discount rule status.
     * @readonly
     */
    status?: Status$1;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
interface DiscountTrigger$1 extends DiscountTriggerTriggerOneOf$1 {
    /** Chain multiple triggers with the `and` operator. */
    and?: And$1;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or$1;
    /** Custom trigger. */
    customTrigger?: Custom$1;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange$1;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange$1;
    /**
     * Trigger type.
     *
     * + `AND`: Operator used for chaining multiple triggers. Currently 1 `AND` chain operator is supported.
     * + `SUBTOTAL_RANGE`: Subtotal must be within the specified `subtotalRange` values.
     * + `ITEM_QUANTITY_RANGE`: Quantity of items in scope must be within specified `itemQuantityRange` values.
     * + `CUSTOM`: Custom trigger type defined in `customTrigger` object.
     */
    triggerType?: TriggerType$1;
}
/** @oneof */
interface DiscountTriggerTriggerOneOf$1 {
    /** Chain multiple triggers with the `and` operator. */
    and?: And$1;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or$1;
    /** Custom trigger. */
    customTrigger?: Custom$1;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange$1;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange$1;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
interface Scope$1 extends ScopeScopeItemsOneOf$1 {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter$1;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter$1;
    /** Scope ID. */
    id?: string;
    /** Scope type. */
    type?: ScopeType$1;
}
/** @oneof */
interface ScopeScopeItemsOneOf$1 {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter$1;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter$1;
}
declare enum ScopeType$1 {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
interface CatalogItemFilter$1 {
    /** Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`. */
    catalogAppId?: string;
    /** ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores. */
    catalogItemIds?: string[];
}
interface CustomFilter$1 {
    /** Custom filter app ID, when relevant. */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
interface And$1 {
    /** List of triggers to have an "AND" operator between their results. */
    triggers?: DiscountTrigger$1[];
}
interface Or$1 {
    /** List of triggers to have an "OR" operator between their results. */
    triggers?: DiscountTrigger$1[];
}
interface Custom$1 {
    /** Trigger ID. */
    id?: string;
    /** ID of the app that created the trigger. */
    appId?: string;
}
interface SubtotalRange$1 {
    /** Relevant scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope$1[];
    /** Minimum subtotal price (inclusive). */
    from?: string | null;
    /** Maximum subtotal price (inclusive). */
    to?: string | null;
}
interface ItemQuantityRange$1 {
    /** Relevant scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope$1[];
    /** Minimum item quantity (inclusive). */
    from?: number | null;
    /** Maximum item quantity (inclusive). */
    to?: number | null;
}
declare enum TriggerType$1 {
    UNDEFINED = "UNDEFINED",
    /** Chain multiple triggers with AND operator */
    AND = "AND",
    /** Subtotal range trigger */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Item quantity range trigger */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger, see Custom Triggers SPI for more details */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
interface ActiveTimeInfo$1 {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
interface Discounts$1 {
    /** Discounts. */
    values?: Discount$1[];
}
interface Discount$1 extends DiscountDiscountOneOf$1 {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
    /**
     * Discount target.
     *
     * + `SPECIFIC_ITEMS`: Discount applies to a specific set of items.
     */
    targetType?: Type$1;
    /** Data related to `SPECIFIC_ITEMS` target type. */
    specificItemsInfo?: SpecificItemsInfo$1;
    /**
     * Discount type.
     *
     * + `PERCENTAGE`: Price is reduced by percentage value.
     * + `FIXED_AMOUNT`: Price is reduced by fixed amount.
     * + `FIXED_PRICE`: Price will be set to fixed amount.
     */
    discountType?: DiscountType$1;
}
/** @oneof */
interface DiscountDiscountOneOf$1 {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
}
declare enum Type$1 {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
interface SpecificItemsInfo$1 {
    /** All associated scopes for `SPECIFIC_ITEMS` target type. */
    scopes?: Scope$1[];
}
declare enum DiscountType$1 {
    UNDEFINED = "UNDEFINED",
    /** Percentage discount */
    PERCENTAGE = "PERCENTAGE",
    /** Fixed amount discount */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Fixed price discount */
    FIXED_PRICE = "FIXED_PRICE"
}
declare enum Status$1 {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** TODO: check if can be removed */
declare enum AppliedSubjectType$1 {
    UNDEFINED = "UNDEFINED",
    /** Discount applies to all items at checkout. */
    ALL_ITEMS = "ALL_ITEMS",
    /** Discount applies to the lowest priced item at checkout. */
    LOWEST_PRICED_ITEM = "LOWEST_PRICED_ITEM"
}
interface CreateDiscountRuleRequest$1 {
    /** Discount rule info. */
    discountRule: DiscountRule$1;
}
interface CreateDiscountRuleResponse$1 {
    /** Discount rule. */
    discountRule?: DiscountRule$1;
}
interface GetDiscountRuleRequest$1 {
    /** ID of the discount rule to retrieve. */
    discountRuleId: string;
}
interface GetDiscountRuleResponse$1 {
    /** The requested discount rule. */
    discountRule?: DiscountRule$1;
}
interface UpdateDiscountRuleRequest$1 {
    /** Discount rule info. */
    discountRule: DiscountRule$1;
}
interface UpdateDiscountRuleResponse$1 {
    /** Updated discount rule. */
    discountRule?: DiscountRule$1;
}
interface DeleteDiscountRuleRequest$1 {
    /** ID of the discount rule to delete. */
    discountRuleId: string;
}
interface DeleteDiscountRuleResponse$1 {
}
interface QueryDiscountRulesRequest$1 {
    /** Query options. */
    query?: PlatformQuery$1;
}
interface PlatformQuery$1 extends PlatformQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$1;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting$1[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$1;
}
interface Sorting$1 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$1;
}
declare enum SortOrder$1 {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging$1 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryDiscountRulesResponse$1 {
    /** List of discount rules. */
    discountRules?: DiscountRule$1[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata$1;
}
interface PlatformPagingMetadata$1 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$1;
}
interface Cursors$1 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface AndNonNullableFields$1 {
    triggers: DiscountTriggerNonNullableFields$1[];
}
interface OrNonNullableFields$1 {
    triggers: DiscountTriggerNonNullableFields$1[];
}
interface CustomNonNullableFields$1 {
    id: string;
    appId: string;
}
interface CatalogItemFilterNonNullableFields$1 {
    catalogAppId: string;
    catalogItemIds: string[];
}
interface CustomFilterNonNullableFields$1 {
    appId: string;
}
interface ScopeNonNullableFields$1 {
    catalogItemFilter?: CatalogItemFilterNonNullableFields$1;
    customFilter?: CustomFilterNonNullableFields$1;
    id: string;
    type: ScopeType$1;
}
interface SubtotalRangeNonNullableFields$1 {
    scopes: ScopeNonNullableFields$1[];
}
interface ItemQuantityRangeNonNullableFields$1 {
    scopes: ScopeNonNullableFields$1[];
}
interface DiscountTriggerNonNullableFields$1 {
    and?: AndNonNullableFields$1;
    or?: OrNonNullableFields$1;
    customTrigger?: CustomNonNullableFields$1;
    subtotalRange?: SubtotalRangeNonNullableFields$1;
    itemQuantityRange?: ItemQuantityRangeNonNullableFields$1;
    triggerType: TriggerType$1;
}
interface SpecificItemsInfoNonNullableFields$1 {
    scopes: ScopeNonNullableFields$1[];
}
interface CustomerBuyNonNullableFields$1 {
    minimumQuantity: number;
    scopes: ScopeNonNullableFields$1[];
}
interface CustomerGetNonNullableFields$1 {
    quantity: number;
    scopes: ScopeNonNullableFields$1[];
}
interface BuyXGetYInfoNonNullableFields$1 {
    customerBuys?: CustomerBuyNonNullableFields$1;
    customerGets?: CustomerGetNonNullableFields$1;
}
interface DiscountNonNullableFields$1 {
    percentage: number;
    fixedAmount: string;
    fixedPrice: string;
    targetType: Type$1;
    specificItemsInfo?: SpecificItemsInfoNonNullableFields$1;
    discountType: DiscountType$1;
    buyXGetYInfo?: BuyXGetYInfoNonNullableFields$1;
}
interface DiscountsNonNullableFields$1 {
    values: DiscountNonNullableFields$1[];
}
interface DiscountSettingsNonNullableFields$1 {
    appliesTo: AppliedSubjectType$1;
}
interface DiscountRuleNonNullableFields$1 {
    trigger?: DiscountTriggerNonNullableFields$1;
    discounts?: DiscountsNonNullableFields$1;
    status: Status$1;
    usageCount: number;
    settings?: DiscountSettingsNonNullableFields$1;
}
interface CreateDiscountRuleResponseNonNullableFields$1 {
    discountRule?: DiscountRuleNonNullableFields$1;
}
interface GetDiscountRuleResponseNonNullableFields$1 {
    discountRule?: DiscountRuleNonNullableFields$1;
}
interface UpdateDiscountRuleResponseNonNullableFields$1 {
    discountRule?: DiscountRuleNonNullableFields$1;
}
interface QueryDiscountRulesResponseNonNullableFields$1 {
    discountRules: DiscountRuleNonNullableFields$1[];
}

interface DiscountRule {
    /**
     * Discount rule ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the discount rule is updated.
     * To prevent conflicting changes, the current `revision` must be passed when updating the discount rule.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the discount rule was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the discount rule was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Whether the discount rule is active.
     *
     * Default: `true`
     */
    active?: boolean | null;
    /** Discount rule name. */
    name?: string | null;
    /**
     * Discount rule trigger.
     * A set of conditions that must be met for the `discounts` to be applied.
     * Not passing a trigger will cause the discount to always apply.
     */
    trigger?: DiscountTrigger;
    /** Time frame in which the discount rule is active. */
    activeTimeInfo?: ActiveTimeInfo;
    /**
     * List of discounts that are applied when one or more triggers are met.
     *
     * > **Notes:**
     * >
     * > + Currently, only 1 discount can be defined per discount rule.
     * > + A discount rule can be applied on multiple items per cart.
     * > + A discount rule can only be applied once per item.
     */
    discounts?: Discounts;
    /**
     * Discount rule status.
     * @readonly
     */
    status?: Status;
    /**
     * Number of times the discount rule was used.
     * @readonly
     */
    usageCount?: number;
}
/** DiscountTrigger - description of a set of conditions, that if met, will trigger the associated rule actions */
interface DiscountTrigger extends DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
    /**
     * Trigger type.
     *
     * + `"AND"`: Operator used for chaining multiple triggers. Currently 1 `"AND"` chain operator is supported.
     * + `"SUBTOTAL_RANGE"`: Subtotal must be within the specified `subtotalRange` values.
     * + `"ITEM_QUANTITY_RANGE"`: Quantity of items in scope must be within specified `itemQuantityRange` values.
     * + `"CUSTOM"`: Custom trigger type defined in `customTrigger` object.
     */
    triggerType?: TriggerType;
}
/** @oneof */
interface DiscountTriggerTriggerOneOf {
    /** Chain multiple triggers with the `and` operator. */
    and?: And;
    /** Chain multiple triggers with the `or` operator. */
    or?: Or;
    /** Custom trigger. */
    customTrigger?: Custom;
    /** Subtotal trigger range. */
    subtotalRange?: SubtotalRange;
    /** Item quantity trigger range. */
    itemQuantityRange?: ItemQuantityRange;
}
/**
 * This object represents a scope of catalog items. Examples:
 * 1. All catalog items of a specific app - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id`
 * 2. Specific catalog item - type = CATALOG_ITEM, CatalogItemFilter with `catalog_app_id` + `catalog_item_ids`
 * 3. External catalog filter - type = CUSTOM_FILTER, CustomFilter with 'app_id' + 'params'
 */
interface Scope extends ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
    /** Scope ID. */
    _id?: string;
    /** Scope type. */
    type?: ScopeType;
}
/** @oneof */
interface ScopeScopeItemsOneOf {
    /** Catalog item filter. Must be passed with `type."CATALOG_ITEM"`. */
    catalogItemFilter?: CatalogItemFilter;
    /** Custom filter. Must be passed with `type."CATALOG_ITEM"`. */
    customFilter?: CustomFilter;
}
declare enum ScopeType {
    UNDEFINED_SCOPE = "UNDEFINED_SCOPE",
    /** Specific catalog items */
    CATALOG_ITEM = "CATALOG_ITEM",
    /** Specific items by custom filters */
    CUSTOM_FILTER = "CUSTOM_FILTER"
}
interface CatalogItemFilter {
    /** Catalog App ID. For example, the Wix Stores, Wix Bookings, or 3rd-party `appId`. */
    catalogAppId?: string;
    /** ID of the item within its Wix or 3rd-party catalog. For example, `productId` for Wix Stores. */
    catalogItemIds?: string[];
}
interface CustomFilter {
    /** Custom filter app ID, when relevant. */
    appId?: string;
    /**
     * Custom filter in `{ "key": "value" }` form.
     * For example, an array of `collectionIDs`:
     * `{ ["collectionId": "12345"], ["collectionId": "67890"] }`.
     */
    params?: Record<string, any> | null;
}
interface And {
    /** List of triggers to have an "AND" operator between their results. */
    triggers?: DiscountTrigger[];
}
interface Or {
    /** List of triggers to have an "OR" operator between their results. */
    triggers?: DiscountTrigger[];
}
interface Custom {
    /** Trigger ID. */
    _id?: string;
    /** ID of the app that created the trigger. */
    appId?: string;
}
interface SubtotalRange {
    /** Relevant scopes for `"SPECIFIC_ITEMS"` target type. */
    scopes?: Scope[];
    /** Minimum subtotal price (inclusive). */
    from?: string | null;
    /** Maximum subtotal price (inclusive). */
    to?: string | null;
}
interface ItemQuantityRange {
    /** Relevant scopes for `"SPECIFIC_ITEMS"` target type. */
    scopes?: Scope[];
    /** Minimum item quantity (inclusive). */
    from?: number | null;
    /** Maximum item quantity (inclusive). */
    to?: number | null;
}
declare enum TriggerType {
    UNDEFINED = "UNDEFINED",
    /** Chain multiple triggers with AND operator */
    AND = "AND",
    /** Subtotal range trigger */
    SUBTOTAL_RANGE = "SUBTOTAL_RANGE",
    /** Item quantity range trigger */
    ITEM_QUANTITY_RANGE = "ITEM_QUANTITY_RANGE",
    /** Custom trigger, see Custom Triggers SPI for more details */
    CUSTOM = "CUSTOM",
    /** Chain multiple triggers with OR operator */
    OR = "OR"
}
interface ActiveTimeInfo {
    /** Date and time the discount rule is active **from**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    start?: Date | null;
    /** Date and time the discount rule is active **till**, in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    end?: Date | null;
}
interface Discounts {
    /** Discounts. */
    values?: Discount[];
}
interface Discount extends DiscountDiscountOneOf {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
    /**
     * Discount target.
     *
     * + `"SPECIFIC_ITEMS"`: Discount applies to a specific set of items.
     */
    targetType?: Type;
    /** Data related to `"SPECIFIC_ITEMS"` target type. */
    specificItemsInfo?: SpecificItemsInfo;
    /**
     * Discount type.
     *
     * + `"PERCENTAGE"`: Price is reduced by percentage value.
     * + `"FIXED_AMOUNT"`: Price is reduced by fixed amount.
     * + `"FIXED_PRICE"`: Price will be set to fixed amount.
     */
    discountType?: DiscountType;
}
/** @oneof */
interface DiscountDiscountOneOf {
    /** Percentage to discount from original price. */
    percentage?: number;
    /** Amount to discount from original price. */
    fixedAmount?: string;
    /** Fixed price. Line item will be fixed to this price. */
    fixedPrice?: string;
}
declare enum Type {
    /** Target type is not defined */
    UNDEFINED = "UNDEFINED",
    /** Target type is a set of specific items */
    SPECIFIC_ITEMS = "SPECIFIC_ITEMS"
}
interface SpecificItemsInfo {
    /** All associated scopes for `"SPECIFIC_ITEMS"` target type. */
    scopes?: Scope[];
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** Percentage discount */
    PERCENTAGE = "PERCENTAGE",
    /** Fixed amount discount */
    FIXED_AMOUNT = "FIXED_AMOUNT",
    /** Fixed price discount */
    FIXED_PRICE = "FIXED_PRICE"
}
declare enum Status {
    /** Rule status is not defined. */
    UNDEFINED = "UNDEFINED",
    /** Rule status is live. */
    LIVE = "LIVE",
    /** Rule status is expired, it might have been live in the past. */
    EXPIRED = "EXPIRED",
    /** Rule status is pending, it might be live in the future. */
    PENDING = "PENDING"
}
/** TODO: check if can be removed */
declare enum AppliedSubjectType {
    UNDEFINED = "UNDEFINED",
    /** Discount applies to all items at checkout. */
    ALL_ITEMS = "ALL_ITEMS",
    /** Discount applies to the lowest priced item at checkout. */
    LOWEST_PRICED_ITEM = "LOWEST_PRICED_ITEM"
}
interface CreateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface CreateDiscountRuleResponse {
    /** Discount rule. */
    discountRule?: DiscountRule;
}
interface GetDiscountRuleRequest {
    /** ID of the discount rule to retrieve. */
    discountRuleId: string;
}
interface GetDiscountRuleResponse {
    /** The requested discount rule. */
    discountRule?: DiscountRule;
}
interface UpdateDiscountRuleRequest {
    /** Discount rule info. */
    discountRule: DiscountRule;
}
interface UpdateDiscountRuleResponse {
    /** Updated discount rule. */
    discountRule?: DiscountRule;
}
interface DeleteDiscountRuleRequest {
    /** ID of the discount rule to delete. */
    discountRuleId: string;
}
interface DeleteDiscountRuleResponse {
}
interface QueryDiscountRulesRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryDiscountRulesResponse {
    /** List of discount rules. */
    discountRules?: DiscountRule[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface AndNonNullableFields {
    triggers: DiscountTriggerNonNullableFields[];
}
interface OrNonNullableFields {
    triggers: DiscountTriggerNonNullableFields[];
}
interface CustomNonNullableFields {
    _id: string;
    appId: string;
}
interface CatalogItemFilterNonNullableFields {
    catalogAppId: string;
    catalogItemIds: string[];
}
interface CustomFilterNonNullableFields {
    appId: string;
}
interface ScopeNonNullableFields {
    catalogItemFilter?: CatalogItemFilterNonNullableFields;
    customFilter?: CustomFilterNonNullableFields;
    _id: string;
    type: ScopeType;
}
interface SubtotalRangeNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface ItemQuantityRangeNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface DiscountTriggerNonNullableFields {
    and?: AndNonNullableFields;
    or?: OrNonNullableFields;
    customTrigger?: CustomNonNullableFields;
    subtotalRange?: SubtotalRangeNonNullableFields;
    itemQuantityRange?: ItemQuantityRangeNonNullableFields;
    triggerType: TriggerType;
}
interface SpecificItemsInfoNonNullableFields {
    scopes: ScopeNonNullableFields[];
}
interface CustomerBuyNonNullableFields {
    minimumQuantity: number;
    scopes: ScopeNonNullableFields[];
}
interface CustomerGetNonNullableFields {
    quantity: number;
    scopes: ScopeNonNullableFields[];
}
interface BuyXGetYInfoNonNullableFields {
    customerBuys?: CustomerBuyNonNullableFields;
    customerGets?: CustomerGetNonNullableFields;
}
interface DiscountNonNullableFields {
    percentage: number;
    fixedAmount: string;
    fixedPrice: string;
    targetType: Type;
    specificItemsInfo?: SpecificItemsInfoNonNullableFields;
    discountType: DiscountType;
    buyXGetYInfo?: BuyXGetYInfoNonNullableFields;
}
interface DiscountsNonNullableFields {
    values: DiscountNonNullableFields[];
}
interface DiscountSettingsNonNullableFields {
    appliesTo: AppliedSubjectType;
}
interface DiscountRuleNonNullableFields {
    trigger?: DiscountTriggerNonNullableFields;
    discounts?: DiscountsNonNullableFields;
    status: Status;
    usageCount: number;
    settings?: DiscountSettingsNonNullableFields;
}
interface CreateDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
interface GetDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
interface UpdateDiscountRuleResponseNonNullableFields {
    discountRule?: DiscountRuleNonNullableFields;
}
interface QueryDiscountRulesResponseNonNullableFields {
    discountRules: DiscountRuleNonNullableFields[];
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createDiscountRule(): __PublicMethodMetaInfo<'POST', {}, CreateDiscountRuleRequest, CreateDiscountRuleRequest$1, CreateDiscountRuleResponse & CreateDiscountRuleResponseNonNullableFields, CreateDiscountRuleResponse$1 & CreateDiscountRuleResponseNonNullableFields$1>;
declare function getDiscountRule(): __PublicMethodMetaInfo<'GET', {
    discountRuleId: string;
}, GetDiscountRuleRequest, GetDiscountRuleRequest$1, GetDiscountRuleResponse & GetDiscountRuleResponseNonNullableFields, GetDiscountRuleResponse$1 & GetDiscountRuleResponseNonNullableFields$1>;
declare function updateDiscountRule(): __PublicMethodMetaInfo<'PATCH', {
    discountRuleId: string;
}, UpdateDiscountRuleRequest, UpdateDiscountRuleRequest$1, UpdateDiscountRuleResponse & UpdateDiscountRuleResponseNonNullableFields, UpdateDiscountRuleResponse$1 & UpdateDiscountRuleResponseNonNullableFields$1>;
declare function deleteDiscountRule(): __PublicMethodMetaInfo<'DELETE', {
    discountRuleId: string;
}, DeleteDiscountRuleRequest, DeleteDiscountRuleRequest$1, DeleteDiscountRuleResponse, DeleteDiscountRuleResponse$1>;
declare function queryDiscountRules(): __PublicMethodMetaInfo<'POST', {}, QueryDiscountRulesRequest, QueryDiscountRulesRequest$1, QueryDiscountRulesResponse & QueryDiscountRulesResponseNonNullableFields, QueryDiscountRulesResponse$1 & QueryDiscountRulesResponseNonNullableFields$1>;

export { type __PublicMethodMetaInfo, createDiscountRule, deleteDiscountRule, getDiscountRule, queryDiscountRules, updateDiscountRule };
