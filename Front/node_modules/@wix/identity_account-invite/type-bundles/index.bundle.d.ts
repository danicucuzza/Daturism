type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface AccountInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Account ID.
     * @readonly
     */
    accountId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /**
     * Deprecated. Use `policyIds`.
     * @deprecated
     */
    role?: string;
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user has declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /** Date the invite was last updated. */
    dateUpdated?: Date | null;
    /** Assets the users are invited to join. */
    assignments?: InviteResourceAssignment[];
    /** Invite expiration date. */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface InviteResourceAssignment {
    /** Role ID. */
    policyId?: string;
    /** Resources the user will be able to access. */
    assignments?: InviteAssignment[];
}
interface InviteAssignment {
    /** Full name of resource to be assigned. */
    fullNameResource?: FullNameResource;
}
interface FullNameResource extends FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** @oneof */
interface FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** Site resource context. It indicates that the resource is under a site (can be the site itself or some asset of a site, like a blog post) */
interface SiteResourceContext {
    /** Site ID. */
    metasiteId?: string;
}
/** Account resource contexts. It indicates that the resource is under the account (can be the account itself or some asset of an account, like a logo or a domain) */
interface AccountResourceContext {
    /** Account ID. */
    accountId?: string;
}
interface OrganizationResourceContext {
}
/**
 * A custom resource. Is used to represent some asset that is not a direct resource context (site or account), but something custom.
 * For example: payment method, blog post, domain, logo.
 */
interface Resource {
    /** The resource id. */
    _id?: string | null;
    /** The resource type */
    type?: string | null;
}
interface PolicyCondition {
    /** The type of the condition */
    condition?: ConditionType;
}
interface ConditionType extends ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
/** @oneof */
interface ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
interface SimpleCondition {
    attrName?: string;
    value?: SimpleConditionValue;
    op?: SimpleConditionOperator;
    conditionModelId?: string;
}
interface SimpleConditionValue extends SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
/** @oneof */
interface SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
declare enum SimpleConditionOperator {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
interface JoinedCondition {
    /** The operator that should be used when evaluating the condition */
    op?: JoinedConditionOperator;
    /** The conditions that should be evaluated, and then joined using the operator provided */
    conditions?: ConditionType[];
}
declare enum JoinedConditionOperator {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
interface EnvironmentCondition extends EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
/** @oneof */
interface EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
interface ExperimentCondition {
    spec?: string;
    fallbackValue?: string;
    expectedValue?: string;
}
interface Condition {
    /** The unique identifier of the condition model. Indicates which actions the condition is working on */
    conditionModelId?: string;
    /** The operator that should be evaluated */
    operator?: ConditionOperator;
}
interface ConditionOperator extends ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
/** @oneof */
interface ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
interface EqualOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the other side (attribute/value) */
    attrName?: string;
    /** The value to compare to. If the two parties are equal - we will return true. */
    value?: ConditionValue;
}
interface ConditionValue extends ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
/** @oneof */
interface ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
interface LikeOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the regex values provided. */
    attrName?: string;
    /** The regex values which the attribute value should be evaluated on. If the attribute value matches at least one of the regular expressions provided - we will return true */
    values?: string[];
}
interface ExperimentOperator {
    /** The spec to conduct the experiment on. */
    spec?: string;
    /** The value to use if the experiment could not be conducted */
    fallbackValue?: string;
    /** The expected value of the experiment conduction. If it matches the actual value - true will be returned. Otherwise - false. */
    expectedValue?: string;
}
/** Implies that the policy takes affect only if the depend on subject is permitted as well. */
interface DependOnOperator {
    /** The subject on which the current entry depends on. If the subject is allowed to perform what the query was about - the condition will be evaluated to true. Otherwise - false */
    dependOnSubject?: Subject;
}
interface Subject {
    /** ID of identity assigned to the asset. */
    _id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectType;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext;
}
declare enum SubjectType {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
interface SubjectContext {
    _id?: string;
    contextType?: SubjectContextType;
}
declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface GetAccountInvitesRequest {
}
interface GetAccountInvitesResponse {
    invites?: AccountInvite[];
}
interface GetAccountInviteRequest {
    _id?: string;
}
interface GetAccountInviteResponse {
    invite?: AccountInvite;
}
interface AccountInviteRequest {
    role?: string;
    email?: string;
    policyIds?: string[];
}
interface AccountInviteResponse {
    invite?: AccountInvite;
}
interface CreateInviteRequest {
    /** Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite). */
    subjectsAssignments: SubjectInviteAssignments[];
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface SubjectInviteAssignments {
    /** Invitee's email address. */
    subjectEmail?: string;
    /** Mapping of roles (referred to here as policies) and assets (referred to here as resources) that will be assigned to the invitee when they accept the invite. When no resources are specified, the invitee will be given access to everything within the account. */
    assignments?: InviteResourceAssignment[];
}
interface CreateInviteResponse {
    /** Invites that were sent successfully. */
    successfulInvites?: AccountInvite[];
    /** Invites that failed. */
    failedInvites?: InviteFailure[];
}
interface InviteFailure {
    /** Email address of the failed invite. */
    subjectEmail?: string;
    /** Error description. */
    errorMessage?: string;
}
interface BulkAccountInviteRequest {
    role?: string;
    emails?: string[];
    policyIds?: string[];
}
interface BulkAccountInviteResponse {
    invites?: AccountInvite[];
    failedEmails?: string[];
}
interface ResendAccountInviteRequest {
    inviteId?: string;
    /** The language of emails that will be used only for recipients that don't have a user, in case this parameter is unspecified, the sender's language will be used instead */
    defaultEmailLanguage?: string | null;
}
interface AcceptAccountInviteRequest {
    inviteToken?: string;
}
interface AcceptAccountInviteResponse {
}
interface RevokeAccountInviteRequest {
    inviteId?: string;
}
interface RevokeAccountInviteResponse {
}
interface UpdateAccountInviteRequest {
    inviteId?: string;
    role?: string;
    policyIds?: string[];
}
interface UpdateAccountInviteResponse {
}
interface UpdateAccountInviteAssignmentsRequest {
    inviteId?: string;
    assignments?: InviteResourceAssignment[];
}
interface UpdateAccountInviteAssignmentsResponse {
}
interface ParseAccountInviteTokenRequest {
    inviteToken?: string;
}
interface ParseAccountInviteTokenResponse {
    inviteId?: string;
    accountId?: string;
    status?: InviteStatus;
}
interface SiteResourceContextNonNullableFields {
    metasiteId: string;
}
interface AccountResourceContextNonNullableFields {
    accountId: string;
}
interface FullNameResourceNonNullableFields {
    siteContext?: SiteResourceContextNonNullableFields;
    accountContext?: AccountResourceContextNonNullableFields;
}
interface SimpleConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface SimpleConditionNonNullableFields {
    attrName: string;
    value?: SimpleConditionValueNonNullableFields;
    op: SimpleConditionOperator;
    conditionModelId: string;
}
interface JoinedConditionNonNullableFields {
    op: JoinedConditionOperator;
    conditions: ConditionTypeNonNullableFields[];
}
interface ExperimentConditionNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface EnvironmentConditionNonNullableFields {
    experimentCondition?: ExperimentConditionNonNullableFields;
}
interface ConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface EqualOperatorNonNullableFields {
    attrName: string;
    value?: ConditionValueNonNullableFields;
}
interface LikeOperatorNonNullableFields {
    attrName: string;
    values: string[];
}
interface ExperimentOperatorNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface SubjectContextNonNullableFields {
    _id: string;
    contextType: SubjectContextType;
}
interface SubjectNonNullableFields {
    _id: string;
    subjectType: SubjectType;
    context?: SubjectContextNonNullableFields;
}
interface DependOnOperatorNonNullableFields {
    dependOnSubject?: SubjectNonNullableFields;
}
interface ConditionOperatorNonNullableFields {
    equals?: EqualOperatorNonNullableFields;
    like?: LikeOperatorNonNullableFields;
    experiment?: ExperimentOperatorNonNullableFields;
    dependOn?: DependOnOperatorNonNullableFields;
}
interface ConditionNonNullableFields {
    conditionModelId: string;
    operator?: ConditionOperatorNonNullableFields;
}
interface ConditionTypeNonNullableFields {
    simpleCondition?: SimpleConditionNonNullableFields;
    joinedConditions?: JoinedConditionNonNullableFields;
    environmentCondition?: EnvironmentConditionNonNullableFields;
    condition?: ConditionNonNullableFields;
}
interface PolicyConditionNonNullableFields {
    condition?: ConditionTypeNonNullableFields;
}
interface InviteAssignmentNonNullableFields {
    fullNameResource?: FullNameResourceNonNullableFields;
    condition?: PolicyConditionNonNullableFields;
}
interface InviteResourceAssignmentNonNullableFields {
    policyId: string;
    assignments: InviteAssignmentNonNullableFields[];
}
interface AccountInviteNonNullableFields {
    _id: string;
    accountId: string;
    email: string;
    role: string;
    inviterId: string;
    status: InviteStatus;
    acceptLink: string;
    inviterAccountId: string;
    policyIds: string[];
    assignments: InviteResourceAssignmentNonNullableFields[];
}
interface InviteFailureNonNullableFields {
    subjectEmail: string;
    errorMessage: string;
}
interface CreateInviteResponseNonNullableFields {
    successfulInvites: AccountInviteNonNullableFields[];
    failedInvites: InviteFailureNonNullableFields[];
}
interface CreateInviteOptions {
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}

declare function createInvite$1(httpClient: HttpClient): CreateInviteSignature;
interface CreateInviteSignature {
    /**
     * Creates and sends invite emails to a list of potential team members, inviting them to become team members of the requesting account.
     * The invites may be limited to a specific resource (site or other asset).
     * Maximum 50 invitees can be specified per call.
     *
     * > **Important**: This call requires an account level API key and cannot be authenticated with the standard authorization header. API keys are currently available to selected beta users only.
     * @param - Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite).
     */
    (subjectsAssignments: SubjectInviteAssignments[], options?: CreateInviteOptions | undefined): Promise<CreateInviteResponse & CreateInviteResponseNonNullableFields>;
}

declare const createInvite: MaybeContext<BuildRESTFunction<typeof createInvite$1> & typeof createInvite$1>;

export { type AcceptAccountInviteRequest, type AcceptAccountInviteResponse, type AccountInvite, type AccountInviteRequest, type AccountInviteResponse, type AccountResourceContext, type BulkAccountInviteRequest, type BulkAccountInviteResponse, type Condition, type ConditionOperator, type ConditionOperatorOperatorsOneOf, type ConditionType, type ConditionTypeOfOneOf, type ConditionValue, type ConditionValueValueOneOf, type CreateInviteOptions, type CreateInviteRequest, type CreateInviteResponse, type CreateInviteResponseNonNullableFields, type DependOnOperator, type EnvironmentCondition, type EnvironmentConditionConditionOneOf, type EqualOperator, type ExperimentCondition, type ExperimentOperator, type FullNameResource, type FullNameResourceResourceContextOneOf, type GetAccountInviteRequest, type GetAccountInviteResponse, type GetAccountInvitesRequest, type GetAccountInvitesResponse, type InviteAssignment, type InviteFailure, type InviteResourceAssignment, InviteStatus, type JoinedCondition, JoinedConditionOperator, type LikeOperator, type OrganizationResourceContext, type ParseAccountInviteTokenRequest, type ParseAccountInviteTokenResponse, type PolicyCondition, type ResendAccountInviteRequest, type Resource, type RevokeAccountInviteRequest, type RevokeAccountInviteResponse, type SimpleCondition, SimpleConditionOperator, type SimpleConditionValue, type SimpleConditionValueValueOneOf, type SiteResourceContext, type Subject, type SubjectContext, SubjectContextType, type SubjectInviteAssignments, SubjectType, type UpdateAccountInviteAssignmentsRequest, type UpdateAccountInviteAssignmentsResponse, type UpdateAccountInviteRequest, type UpdateAccountInviteResponse, createInvite };
