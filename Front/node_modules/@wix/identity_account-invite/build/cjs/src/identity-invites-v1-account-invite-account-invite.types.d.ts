export interface AccountInvite {
    /**
     * Invite ID.
     * @readonly
     */
    id?: string;
    /**
     * Account ID.
     * @readonly
     */
    accountId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /**
     * Deprecated. Use `policyIds`.
     * @deprecated
     */
    role?: string;
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user has declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /** Date the invite was last updated. */
    dateUpdated?: Date | null;
    /** Assets the users are invited to join. */
    assignments?: InviteResourceAssignment[];
    /** Invite expiration date. */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
export declare enum InviteStatus {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
export interface InviteResourceAssignment {
    /** Role ID. */
    policyId?: string;
    /** Resources the user will be able to access. */
    assignments?: InviteAssignment[];
}
export interface InviteAssignment {
    /** Full name of resource to be assigned. */
    fullNameResource?: FullNameResource;
}
export interface FullNameResource extends FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** @oneof */
export interface FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** Site resource context. It indicates that the resource is under a site (can be the site itself or some asset of a site, like a blog post) */
export interface SiteResourceContext {
    /** Site ID. */
    metasiteId?: string;
}
/** Account resource contexts. It indicates that the resource is under the account (can be the account itself or some asset of an account, like a logo or a domain) */
export interface AccountResourceContext {
    /** Account ID. */
    accountId?: string;
}
export interface OrganizationResourceContext {
}
/**
 * A custom resource. Is used to represent some asset that is not a direct resource context (site or account), but something custom.
 * For example: payment method, blog post, domain, logo.
 */
export interface Resource {
    /** The resource id. */
    id?: string | null;
    /** The resource type */
    type?: string | null;
}
export interface PolicyCondition {
    /** The type of the condition */
    condition?: ConditionType;
}
export interface ConditionType extends ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
/** @oneof */
export interface ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
export interface SimpleCondition {
    attrName?: string;
    value?: SimpleConditionValue;
    op?: SimpleConditionOperator;
    conditionModelId?: string;
}
export interface SimpleConditionValue extends SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
/** @oneof */
export interface SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
export declare enum SimpleConditionOperator {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
export interface JoinedCondition {
    /** The operator that should be used when evaluating the condition */
    op?: JoinedConditionOperator;
    /** The conditions that should be evaluated, and then joined using the operator provided */
    conditions?: ConditionType[];
}
export declare enum JoinedConditionOperator {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
export interface EnvironmentCondition extends EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
/** @oneof */
export interface EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
export interface ExperimentCondition {
    spec?: string;
    fallbackValue?: string;
    expectedValue?: string;
}
export interface Condition {
    /** The unique identifier of the condition model. Indicates which actions the condition is working on */
    conditionModelId?: string;
    /** The operator that should be evaluated */
    operator?: ConditionOperator;
}
export interface ConditionOperator extends ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
/** @oneof */
export interface ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
export interface EqualOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the other side (attribute/value) */
    attrName?: string;
    /** The value to compare to. If the two parties are equal - we will return true. */
    value?: ConditionValue;
}
export interface ConditionValue extends ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
/** @oneof */
export interface ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
export interface LikeOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the regex values provided. */
    attrName?: string;
    /** The regex values which the attribute value should be evaluated on. If the attribute value matches at least one of the regular expressions provided - we will return true */
    values?: string[];
}
export interface ExperimentOperator {
    /** The spec to conduct the experiment on. */
    spec?: string;
    /** The value to use if the experiment could not be conducted */
    fallbackValue?: string;
    /** The expected value of the experiment conduction. If it matches the actual value - true will be returned. Otherwise - false. */
    expectedValue?: string;
}
/** Implies that the policy takes affect only if the depend on subject is permitted as well. */
export interface DependOnOperator {
    /** The subject on which the current entry depends on. If the subject is allowed to perform what the query was about - the condition will be evaluated to true. Otherwise - false */
    dependOnSubject?: Subject;
}
export interface Subject {
    /** ID of identity assigned to the asset. */
    id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectType;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext;
}
export declare enum SubjectType {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
export interface SubjectContext {
    id?: string;
    contextType?: SubjectContextType;
}
export declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
export interface GetAccountInvitesRequest {
}
export interface GetAccountInvitesResponse {
    invites?: AccountInvite[];
}
export interface GetAccountInviteRequest {
    id?: string;
}
export interface GetAccountInviteResponse {
    invite?: AccountInvite;
}
export interface AccountInviteRequest {
    role?: string;
    email?: string;
    policyIds?: string[];
}
export interface AccountInviteResponse {
    invite?: AccountInvite;
}
export interface CreateInviteRequest {
    /** Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite). */
    subjectsAssignments: SubjectInviteAssignments[];
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
export interface SubjectInviteAssignments {
    /** Invitee's email address. */
    subjectEmail?: string;
    /** Mapping of roles (referred to here as policies) and assets (referred to here as resources) that will be assigned to the invitee when they accept the invite. When no resources are specified, the invitee will be given access to everything within the account. */
    assignments?: InviteResourceAssignment[];
}
export interface CreateInviteResponse {
    /** Invites that were sent successfully. */
    successfulInvites?: AccountInvite[];
    /** Invites that failed. */
    failedInvites?: InviteFailure[];
}
export interface InviteFailure {
    /** Email address of the failed invite. */
    subjectEmail?: string;
    /** Error description. */
    errorMessage?: string;
}
export interface BulkAccountInviteRequest {
    role?: string;
    emails?: string[];
    policyIds?: string[];
}
export interface BulkAccountInviteResponse {
    invites?: AccountInvite[];
    failedEmails?: string[];
}
export interface ResendAccountInviteRequest {
    inviteId?: string;
    /** The language of emails that will be used only for recipients that don't have a user, in case this parameter is unspecified, the sender's language will be used instead */
    defaultEmailLanguage?: string | null;
}
export interface AcceptAccountInviteRequest {
    inviteToken?: string;
}
export interface AcceptAccountInviteResponse {
}
export interface RevokeAccountInviteRequest {
    inviteId?: string;
}
export interface RevokeAccountInviteResponse {
}
export interface UpdateAccountInviteRequest {
    inviteId?: string;
    role?: string;
    policyIds?: string[];
}
export interface UpdateAccountInviteResponse {
}
export interface UpdateAccountInviteAssignmentsRequest {
    inviteId?: string;
    assignments?: InviteResourceAssignment[];
}
export interface UpdateAccountInviteAssignmentsResponse {
}
export interface ParseAccountInviteTokenRequest {
    inviteToken?: string;
}
export interface ParseAccountInviteTokenResponse {
    inviteId?: string;
    accountId?: string;
    status?: InviteStatus;
}
interface SiteResourceContextNonNullableFields {
    metasiteId: string;
}
interface AccountResourceContextNonNullableFields {
    accountId: string;
}
interface FullNameResourceNonNullableFields {
    siteContext?: SiteResourceContextNonNullableFields;
    accountContext?: AccountResourceContextNonNullableFields;
}
interface SimpleConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface SimpleConditionNonNullableFields {
    attrName: string;
    value?: SimpleConditionValueNonNullableFields;
    op: SimpleConditionOperator;
    conditionModelId: string;
}
interface JoinedConditionNonNullableFields {
    op: JoinedConditionOperator;
    conditions: ConditionTypeNonNullableFields[];
}
interface ExperimentConditionNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface EnvironmentConditionNonNullableFields {
    experimentCondition?: ExperimentConditionNonNullableFields;
}
interface ConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface EqualOperatorNonNullableFields {
    attrName: string;
    value?: ConditionValueNonNullableFields;
}
interface LikeOperatorNonNullableFields {
    attrName: string;
    values: string[];
}
interface ExperimentOperatorNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface SubjectContextNonNullableFields {
    id: string;
    contextType: SubjectContextType;
}
interface SubjectNonNullableFields {
    id: string;
    subjectType: SubjectType;
    context?: SubjectContextNonNullableFields;
}
interface DependOnOperatorNonNullableFields {
    dependOnSubject?: SubjectNonNullableFields;
}
interface ConditionOperatorNonNullableFields {
    equals?: EqualOperatorNonNullableFields;
    like?: LikeOperatorNonNullableFields;
    experiment?: ExperimentOperatorNonNullableFields;
    dependOn?: DependOnOperatorNonNullableFields;
}
interface ConditionNonNullableFields {
    conditionModelId: string;
    operator?: ConditionOperatorNonNullableFields;
}
interface ConditionTypeNonNullableFields {
    simpleCondition?: SimpleConditionNonNullableFields;
    joinedConditions?: JoinedConditionNonNullableFields;
    environmentCondition?: EnvironmentConditionNonNullableFields;
    condition?: ConditionNonNullableFields;
}
interface PolicyConditionNonNullableFields {
    condition?: ConditionTypeNonNullableFields;
}
interface InviteAssignmentNonNullableFields {
    fullNameResource?: FullNameResourceNonNullableFields;
    condition?: PolicyConditionNonNullableFields;
}
interface InviteResourceAssignmentNonNullableFields {
    policyId: string;
    assignments: InviteAssignmentNonNullableFields[];
}
interface AccountInviteNonNullableFields {
    id: string;
    accountId: string;
    email: string;
    role: string;
    inviterId: string;
    status: InviteStatus;
    acceptLink: string;
    inviterAccountId: string;
    policyIds: string[];
    assignments: InviteResourceAssignmentNonNullableFields[];
}
interface InviteFailureNonNullableFields {
    subjectEmail: string;
    errorMessage: string;
}
export interface CreateInviteResponseNonNullableFields {
    successfulInvites: AccountInviteNonNullableFields[];
    failedInvites: InviteFailureNonNullableFields[];
}
export {};
