type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface Contributor {
    /** Contributor's metadata. */
    metaData?: PersonMetaData;
    /** Whether the contributor account is a team account. */
    isTeam?: boolean | null;
    /** Date that the contributor joined the site. */
    joinedAt?: Date | null;
    /** Email address that received the invite. */
    invitedEmail?: string | null;
    /** Whether the contributor account is a client account. */
    isClient?: boolean | null;
    /**
     * Contributor's user ID.
     * @readonly
     */
    _id?: string;
}
interface PersonMetaData {
    /** Contributor's account ID. */
    _id?: string;
    /** Contributor's full name. */
    fullName?: string | null;
    /** URL for contributor's profile image. */
    imageUrl?: string | null;
    /** Contributor's email address. */
    email?: string | null;
    /** Contributor's access to assets and their assigned role (`policy`) for that asset. */
    assignments?: Assignment[];
}
interface Assignment {
    /** Role assigned to the user. */
    policy?: AssignedPolicy;
    /** Unique ID for this specific assignment. */
    assignmentId?: string;
    /** Identity assigned to the asset in an assignment, referred to as subject. Supported subjects include user IDs, account IDs, and app IDs. */
    subject?: Subject;
}
interface AssignedPolicy {
    /** Role ID. */
    policyId?: string;
    /** Role title. */
    title?: string | null;
    /** Role description. */
    description?: string | null;
}
interface Restriction extends RestrictionRestrictionsOneOf {
    /**
     * Deprecated.
     * @deprecated
     */
    resource?: Resource;
    /** List of conditions restricting the user's access. Currently only folder conditions are supported. */
    conditions?: Conditions;
    /** Site where the assignment restrictions apply. */
    site?: SiteRestriction;
}
/** @oneof */
interface RestrictionRestrictionsOneOf {
    /**
     * Deprecated.
     * @deprecated
     */
    resource?: Resource;
    /** List of conditions restricting the user's access. Currently only folder conditions are supported. */
    conditions?: Conditions;
    /** Site where the assignment restrictions apply. */
    site?: SiteRestriction;
}
interface Resource {
    /** Resource type. */
    resourceType?: ResourceType;
    /** Resource ID. */
    _id?: string;
    value?: string | null;
}
declare enum ResourceType {
    UNKNOWN_RESOURCE_TYPE = "UNKNOWN_RESOURCE_TYPE",
    SITE = "SITE"
}
interface Conditions {
    /** List of conditions. */
    conditions?: Condition[];
}
interface Condition {
    /** Condition type. */
    conditionType?: ConditionAttributeType;
    /** Condition ID. */
    _id?: string;
    /** Expected value of the condition. When `conditionType` = "FOLDER", this is the folder path. */
    value?: string | null;
}
declare enum ConditionAttributeType {
    UNKNOWN_CONDITION_TYPE = "UNKNOWN_CONDITION_TYPE",
    FOLDER = "FOLDER"
}
interface SiteRestriction {
    /** Site ID. */
    _id?: string;
    /** Site name. */
    value?: string | null;
}
interface CompanionResource {
    /** Asset ID (referred to here as resource ID). */
    _id?: string;
    /** Asset type (referred to here as resource type). as predefined in the authorization system */
    resourceType?: string;
}
interface Subject {
    /** ID of identity assigned to the asset. */
    _id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectType;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext;
}
declare enum SubjectType {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
interface SubjectContext {
    _id?: string;
    contextType?: SubjectContextType;
}
declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface GetAppContributorsRequest {
    appId?: string;
    /** The locale of the request. Defaults to en-us. */
    locale?: string | null;
}
interface GetAppContributorsResponse {
    contributors?: Contributor[];
    invites?: AppInvite[];
}
interface AppInvite {
    /** @readonly */
    _id?: string;
    /** TODO: amitis - remove this comment after the next merge */
    destEmail?: string;
    /** @readonly */
    status?: string;
    /** @readonly */
    acceptLink?: string;
    invitePurpose?: string | null;
    policies?: AssignedPolicy[];
    /** @readonly */
    expirationDate?: Date | null;
    /** @readonly */
    dateCreated?: Date | null;
    /** @readonly */
    dateUpdated?: Date | null;
}
interface GetSiteContributorsRequest {
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface GetSiteContributorsResponse {
    users?: User[];
    teams?: Team[];
    invites?: SiteInvite[];
    policies?: Policy[];
    permissions?: string[];
    userId?: string;
    loggedInAccountId?: string;
    pendingOwner?: PendingOwner;
    contributorLimit?: ContributorLimit;
    predefinedRoles?: PredefinedRoles;
}
interface User {
    /** User ID. */
    _id?: string;
    /**
     * Deprecated.
     * @deprecated
     */
    roles?: string[];
    /** User's email address. */
    email?: string;
    /** User's name. */
    name?: Name;
    /** URL to user's profile image, when provided. */
    profileImage?: string | null;
    /** Date the user joined the team. */
    joinedTeamAt?: Date | null;
    /**
     * Deprecated.
     * @deprecated
     */
    policyIds?: string[];
    /** Resources the user can access. */
    assignments?: Assignment[];
}
interface Name {
    /** User's first name. */
    firstName?: string;
    /** User's last name. */
    lastName?: string;
}
interface Team {
    accountId?: string;
    accountInfo?: AccountInfo;
    policyIds?: string[];
    joinedAt?: Date | null;
}
interface AccountInfo {
    accountName?: string;
    accountImage?: string;
    isTeam?: boolean;
}
interface SiteInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Site ID the user is invited to as a collaborator.
     * @readonly
     */
    siteId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite Status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** User's Wix Bookings staff ID, if relevant. */
    staffId?: string | null;
    /** Invite expiration date */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface Policy {
    _id?: string;
    description?: string | null;
    name?: string | null;
    isCustom?: boolean;
    scopes?: string[];
}
interface PendingOwner {
    email?: string;
    expirationDate?: Date | null;
    acceptLink?: string;
}
interface ContributorLimit {
    contributorLimit?: number;
}
interface PredefinedRoles {
    roles?: PredefinedRole[];
}
interface PredefinedRole {
    titleKey?: string;
    roles?: Role[];
    title?: string | null;
    areaId?: string;
}
interface Role {
    _id?: string;
    deprecatedKey?: string;
    /** @deprecated */
    titleKey?: string;
    /** @deprecated */
    descriptionKey?: string;
    deprecated?: boolean;
    restrictFromLevel?: string;
    experiments?: string[];
    appDefIds?: string[];
    title?: string | null;
    description?: string | null;
    isCustom?: boolean;
    scopes?: string[];
    availableResourceTypes?: ResourceType[];
    availableConditions?: ConditionAttributeType[];
    limitToEditorTypes?: string[];
}
interface GetSiteContributorsV2Request {
    /** The locale of the request. Defaults to en-us. */
    locale?: string | null;
}
interface GetSiteContributorsV2Response {
    /** List of contributors of the given site. */
    contributors?: Contributor[];
    /** List of invites to contribute to the given site. */
    invites?: SiteInvite[];
    /** Quota information for contributors on the given site. */
    contributorsQuota?: ContributorsQuota;
}
interface ContributorsQuota extends ContributorsQuotaOptionsOneOf {
    /** Limited contributors quota details. */
    limitedOptions?: LimitedOptions;
    /** Type of contributors quota */
    type?: Type;
}
/** @oneof */
interface ContributorsQuotaOptionsOneOf {
    /** Limited contributors quota details. */
    limitedOptions?: LimitedOptions;
}
/** Enum to represent different types of contributors quota. */
declare enum Type {
    UNKNOWN = "UNKNOWN",
    LIMITED = "LIMITED",
    UNLIMITED = "UNLIMITED"
}
/** Details for a limited contributors quota. */
interface LimitedOptions {
    /** Maximum number of contributors allowed. */
    limit?: number;
    /** Number of accepted or pending invitations. */
    used?: number;
}
interface HandleSiteTransferRequest {
    originalOwnerAccountId?: string;
    newOwnerAccountId?: string;
    metaSiteId?: string;
    keepOriginalOwnerAsContributor?: boolean;
}
interface HandleSiteTransferResponse {
}
interface GetCurrentUserRolesRequest {
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface GetCurrentUserRolesResponse {
    roles?: LocalizedRole[];
}
interface LocalizedRole {
    name?: string;
    description?: string | null;
}
interface BulkGetUserRolesOnSiteRequest {
    users?: UserSubject[];
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface UserSubject {
    userId?: string;
    accountId?: string;
}
interface BulkGetUserRolesOnSiteResponse {
    userRoles?: UserLocalizedRoles[];
}
interface UserLocalizedRoles {
    user?: UserSubject;
    roles?: LocalizedRole[];
}
interface ChangeContributorRoleRequest {
    /** Contributor's account ID. */
    accountId: string;
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment[];
}
interface SiteRoleAssignment {
    /** Role ID. Sometimes referred to as policy ID. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for a list of available roles. */
    roleId?: string;
    /**
     * Assignment ID mapping the role to the contributor on the site.
     * @readonly
     */
    assignmentId?: string;
}
interface ChangeContributorRoleResponse {
    /** New roles assigned to the contributor on the site. */
    newAssignedRoles?: SiteRoleAssignment[];
}
interface QuerySiteContributorsRequest {
    filter?: QuerySiteContributorsFilter;
}
interface QuerySiteContributorsFilter {
    /** Role IDs (referred to here as policy IDs) to return. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for available roles. */
    policyIds?: string[];
}
declare enum FieldSet {
    UNKNOWN = "UNKNOWN",
    /** Include only `account_id` and `account_owner_id` fields. */
    META_DATA = "META_DATA"
}
interface QuerySiteContributorsResponse {
    /** List of site contributors. */
    contributors?: ContributorV2[];
}
interface ContributorV2 {
    /** Contributor's account ID. */
    accountId?: string | null;
    /** User ID of the owner of the account that the contributor has joined. */
    accountOwnerId?: string | null;
}
interface GetContributorsQuotaRequest {
}
interface GetContributorsQuotaResponse {
    /** Quota information for contributors on the given site. */
    contributorsQuota?: ContributorsQuota;
}
interface SiteRoleAssignmentNonNullableFields {
    roleId: string;
    assignmentId: string;
}
interface ChangeContributorRoleResponseNonNullableFields {
    newAssignedRoles: SiteRoleAssignmentNonNullableFields[];
}
interface ChangeRoleOptions {
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment[];
}
interface QuerySiteContributorsOptions {
    filter?: QuerySiteContributorsFilter;
}

declare function changeRole$1(httpClient: HttpClient): ChangeRoleSignature;
interface ChangeRoleSignature {
    /**
     * Overrides all the roles of a contributor for the specified site.
     * @param - Contributor's account ID.
     */
    (accountId: string, options: ChangeRoleOptions): Promise<ChangeContributorRoleResponse & ChangeContributorRoleResponseNonNullableFields>;
}
declare function querySiteContributors$1(httpClient: HttpClient): QuerySiteContributorsSignature;
interface QuerySiteContributorsSignature {
    /**
     * Retrieves a list of contributors for the specified site, given the provided filters.
     */
    (options?: QuerySiteContributorsOptions | undefined): Promise<QuerySiteContributorsResponse>;
}

declare const changeRole: MaybeContext<BuildRESTFunction<typeof changeRole$1> & typeof changeRole$1>;
declare const querySiteContributors: MaybeContext<BuildRESTFunction<typeof querySiteContributors$1> & typeof querySiteContributors$1>;

export { type AccountInfo, type AppInvite, type AssignedPolicy, type Assignment, type BulkGetUserRolesOnSiteRequest, type BulkGetUserRolesOnSiteResponse, type ChangeContributorRoleRequest, type ChangeContributorRoleResponse, type ChangeContributorRoleResponseNonNullableFields, type ChangeRoleOptions, type CompanionResource, type Condition, ConditionAttributeType, type Conditions, type Contributor, type ContributorLimit, type ContributorV2, type ContributorsQuota, type ContributorsQuotaOptionsOneOf, FieldSet, type GetAppContributorsRequest, type GetAppContributorsResponse, type GetContributorsQuotaRequest, type GetContributorsQuotaResponse, type GetCurrentUserRolesRequest, type GetCurrentUserRolesResponse, type GetSiteContributorsRequest, type GetSiteContributorsResponse, type GetSiteContributorsV2Request, type GetSiteContributorsV2Response, type HandleSiteTransferRequest, type HandleSiteTransferResponse, InviteStatus, type LimitedOptions, type LocalizedRole, type Name, type PendingOwner, type PersonMetaData, type Policy, type PredefinedRole, type PredefinedRoles, type QuerySiteContributorsFilter, type QuerySiteContributorsOptions, type QuerySiteContributorsRequest, type QuerySiteContributorsResponse, type Resource, ResourceType, type Restriction, type RestrictionRestrictionsOneOf, type Role, type SiteInvite, type SiteRestriction, type SiteRoleAssignment, type Subject, type SubjectContext, SubjectContextType, SubjectType, type Team, Type, type User, type UserLocalizedRoles, type UserSubject, changeRole, querySiteContributors };
