interface RegisterV2Request$1 {
    /** Identifier of registering member. */
    loginId: LoginId$1;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile$5;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken$1[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId$1 extends LoginIdTypeOneOf$1 {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf$1 {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile$5 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$5;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$5[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$5[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$5[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$5[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$5 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$5 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$5;
}
interface V1CustomValue$5 extends V1CustomValueValueOneOf$5 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$5;
    /** Map value. */
    mapValue?: V1MapValue$5;
}
/** @oneof */
interface V1CustomValueValueOneOf$5 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$5;
    /** Map value. */
    mapValue?: V1MapValue$5;
}
interface V1ListValue$5 {
    /** Custom value. */
    value?: V1CustomValue$5[];
}
interface V1MapValue$5 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$5>;
}
interface SecondaryEmail$5 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$5;
}
declare enum EmailTag$5 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$5 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$5;
}
declare enum PhoneTag$5 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$5 {
    /** Address. */
    address?: Address$5;
    /** Address tag. */
    tag?: AddressTag$5;
}
/** Physical address */
interface Address$5 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$5 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken$1 extends CaptchaTokenTokenOneOf$1 {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf$1 {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse$5 {
    /** The current state of the login or registration process. */
    state?: StateType$5;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$5;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$5>;
}
declare enum StateType$5 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$5 {
    /** Identity ID */
    id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$5[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$5[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$5;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$5;
    /** Identity email address. */
    email?: Email$5;
    /** Identity's current status. */
    status?: StatusV2$5;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$5[];
}
interface Identifier$5 extends IdentifierValueOneOf$5 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$5 {
    email?: string;
    userName?: string;
}
interface Connection$5 extends ConnectionTypeOneOf$5 {
    /** IDP connection. */
    idpConnection?: IdpConnection$5;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$5;
}
/** @oneof */
interface ConnectionTypeOneOf$5 {
    /** IDP connection. */
    idpConnection?: IdpConnection$5;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$5;
}
interface IdpConnection$5 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$5 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata$5 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$5 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$5 {
    name?: StatusName$5;
    reasons?: Reason$5[];
}
declare enum StatusName$5 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$5 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$5 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$5;
    /** Factor status. */
    status?: Status$5;
}
declare enum FactorType$5 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$5 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$5 extends CustomValueValueOneOf$5 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$5;
    /** Map value. */
    mapValue?: MapValue$5;
}
/** @oneof */
interface CustomValueValueOneOf$5 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$5;
    /** Map value. */
    mapValue?: MapValue$5;
}
interface ListValue$5 {
    /** Custom value. */
    value?: CustomValue$5[];
}
interface MapValue$5 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$5>;
}
interface LoginV2Request$1 {
    /** Identifier of identity logging in. */
    loginId: LoginId$1;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken$1[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest$1 {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse$1 {
}
interface LoginWithIdpConnectionRequest$1 {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType$1;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType$1 {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse$3 {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry$3[];
}
interface HeadersEntry$3 {
    key?: string;
    value?: string;
}
interface RawHttpRequest$3 {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$3[];
    queryParams?: QueryParametersEntry$3[];
    headers?: HeadersEntry$3[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry$3 {
    key?: string;
    value?: string;
}
interface QueryParametersEntry$3 {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest$1 {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest$1 {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest$1 {
    /** the identifier of the identity */
    loginId: LoginId$1;
    /** profile of the identity */
    profile?: IdentityProfile$5;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse$1 {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity$5;
}
/** logout request payload */
interface LogoutRequest$1 {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields$5 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$5 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$5 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$5 {
    idpConnection?: IdpConnectionNonNullableFields$5;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$5;
}
interface V1ListValueNonNullableFields$5 {
    value: V1CustomValueNonNullableFields$5[];
}
interface V1CustomValueNonNullableFields$5 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$5;
}
interface CustomFieldNonNullableFields$5 {
    name: string;
    value?: V1CustomValueNonNullableFields$5;
}
interface SecondaryEmailNonNullableFields$5 {
    email: string;
    tag: EmailTag$5;
}
interface PhoneNonNullableFields$5 {
    phone: string;
    tag: PhoneTag$5;
}
interface AddressWrapperNonNullableFields$5 {
    tag: AddressTag$5;
}
interface IdentityProfileNonNullableFields$5 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$5;
    customFields: CustomFieldNonNullableFields$5[];
    secondaryEmails: SecondaryEmailNonNullableFields$5[];
    phonesV2: PhoneNonNullableFields$5[];
    addresses: AddressWrapperNonNullableFields$5[];
}
interface MetadataNonNullableFields$5 {
    tags: string[];
}
interface EmailNonNullableFields$5 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$5 {
    name: StatusName$5;
    reasons: Reason$5[];
}
interface FactorNonNullableFields$5 {
    factorId: string;
    type: FactorType$5;
    status: Status$5;
}
interface IdentityNonNullableFields$5 {
    identifiers: IdentifierNonNullableFields$5[];
    connections: ConnectionNonNullableFields$5[];
    identityProfile?: IdentityProfileNonNullableFields$5;
    metadata?: MetadataNonNullableFields$5;
    email?: EmailNonNullableFields$5;
    status?: StatusV2NonNullableFields$5;
    factors: FactorNonNullableFields$5[];
}
interface StateMachineResponseNonNullableFields$5 {
    state: StateType$5;
    identity?: IdentityNonNullableFields$5;
}
interface HeadersEntryNonNullableFields$3 {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields$3 {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields$3[];
}
interface SignOnResponseNonNullableFields$1 {
    sessionToken: string;
    identity?: IdentityNonNullableFields$5;
}

interface RegisterV2Request {
    /** Identifier of registering member. */
    loginId: LoginId;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile$4;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId extends LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile$4 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$4;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$4[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$4[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$4[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$4[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$4 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$4 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$4;
}
interface V1CustomValue$4 extends V1CustomValueValueOneOf$4 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$4;
    /** Map value. */
    mapValue?: V1MapValue$4;
}
/** @oneof */
interface V1CustomValueValueOneOf$4 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$4;
    /** Map value. */
    mapValue?: V1MapValue$4;
}
interface V1ListValue$4 {
    /** Custom value. */
    value?: V1CustomValue$4[];
}
interface V1MapValue$4 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$4>;
}
interface SecondaryEmail$4 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$4;
}
declare enum EmailTag$4 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$4 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$4;
}
declare enum PhoneTag$4 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$4 {
    /** Address. */
    address?: Address$4;
    /** Address tag. */
    tag?: AddressTag$4;
}
/** Physical address */
interface Address$4 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$4 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken extends CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse$4 {
    /** The current state of the login or registration process. */
    state?: StateType$4;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$4;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$4>;
}
declare enum StateType$4 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$4 {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$4[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$4[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$4;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$4;
    /** Identity email address. */
    email?: Email$4;
    /** Identity's current status. */
    status?: StatusV2$4;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$4[];
}
interface Identifier$4 extends IdentifierValueOneOf$4 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$4 {
    email?: string;
    userName?: string;
}
interface Connection$4 extends ConnectionTypeOneOf$4 {
    /** IDP connection. */
    idpConnection?: IdpConnection$4;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$4;
}
/** @oneof */
interface ConnectionTypeOneOf$4 {
    /** IDP connection. */
    idpConnection?: IdpConnection$4;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$4;
}
interface IdpConnection$4 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$4 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata$4 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$4 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$4 {
    name?: StatusName$4;
    reasons?: Reason$4[];
}
declare enum StatusName$4 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$4 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$4 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$4;
    /** Factor status. */
    status?: Status$4;
}
declare enum FactorType$4 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$4 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$4 extends CustomValueValueOneOf$4 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$4;
    /** Map value. */
    mapValue?: MapValue$4;
}
/** @oneof */
interface CustomValueValueOneOf$4 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$4;
    /** Map value. */
    mapValue?: MapValue$4;
}
interface ListValue$4 {
    /** Custom value. */
    value?: CustomValue$4[];
}
interface MapValue$4 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$4>;
}
interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse {
}
interface LoginWithIdpConnectionRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse$2 {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry$2[];
}
interface HeadersEntry$2 {
    key?: string;
    value?: string;
}
interface RawHttpRequest$2 {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$2[];
    queryParams?: QueryParametersEntry$2[];
    headers?: HeadersEntry$2[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry$2 {
    key?: string;
    value?: string;
}
interface QueryParametersEntry$2 {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile$4;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity$4;
}
/** logout request payload */
interface LogoutRequest {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields$4 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$4 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$4 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$4 {
    idpConnection?: IdpConnectionNonNullableFields$4;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$4;
}
interface V1ListValueNonNullableFields$4 {
    value: V1CustomValueNonNullableFields$4[];
}
interface V1CustomValueNonNullableFields$4 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$4;
}
interface CustomFieldNonNullableFields$4 {
    name: string;
    value?: V1CustomValueNonNullableFields$4;
}
interface SecondaryEmailNonNullableFields$4 {
    email: string;
    tag: EmailTag$4;
}
interface PhoneNonNullableFields$4 {
    phone: string;
    tag: PhoneTag$4;
}
interface AddressWrapperNonNullableFields$4 {
    tag: AddressTag$4;
}
interface IdentityProfileNonNullableFields$4 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$4;
    customFields: CustomFieldNonNullableFields$4[];
    secondaryEmails: SecondaryEmailNonNullableFields$4[];
    phonesV2: PhoneNonNullableFields$4[];
    addresses: AddressWrapperNonNullableFields$4[];
}
interface MetadataNonNullableFields$4 {
    tags: string[];
}
interface EmailNonNullableFields$4 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$4 {
    name: StatusName$4;
    reasons: Reason$4[];
}
interface FactorNonNullableFields$4 {
    factorId: string;
    type: FactorType$4;
    status: Status$4;
}
interface IdentityNonNullableFields$4 {
    identifiers: IdentifierNonNullableFields$4[];
    connections: ConnectionNonNullableFields$4[];
    identityProfile?: IdentityProfileNonNullableFields$4;
    metadata?: MetadataNonNullableFields$4;
    email?: EmailNonNullableFields$4;
    status?: StatusV2NonNullableFields$4;
    factors: FactorNonNullableFields$4[];
}
interface StateMachineResponseNonNullableFields$4 {
    state: StateType$4;
    identity?: IdentityNonNullableFields$4;
}
interface HeadersEntryNonNullableFields$2 {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields$2 {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields$2[];
}
interface SignOnResponseNonNullableFields {
    sessionToken: string;
    identity?: IdentityNonNullableFields$4;
}

type __PublicMethodMetaInfo$6<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function registerV2(): __PublicMethodMetaInfo$6<'POST', {}, RegisterV2Request, RegisterV2Request$1, StateMachineResponse$4 & StateMachineResponseNonNullableFields$4, StateMachineResponse$5 & StateMachineResponseNonNullableFields$5>;
declare function loginV2(): __PublicMethodMetaInfo$6<'POST', {}, LoginV2Request, LoginV2Request$1, StateMachineResponse$4 & StateMachineResponseNonNullableFields$4, StateMachineResponse$5 & StateMachineResponseNonNullableFields$5>;
declare function changePassword(): __PublicMethodMetaInfo$6<'POST', {}, ChangePasswordRequest, ChangePasswordRequest$1, ChangePasswordResponse, ChangePasswordResponse$1>;
declare function loginWithIdpConnection(): __PublicMethodMetaInfo$6<'GET', {
    tenantId: string;
    idpConnectionId: string;
}, LoginWithIdpConnectionRequest, LoginWithIdpConnectionRequest$1, RawHttpResponse$2 & RawHttpResponseNonNullableFields$2, RawHttpResponse$3 & RawHttpResponseNonNullableFields$3>;
declare function loginWithIdpConnectionCallback(): __PublicMethodMetaInfo$6<'GET', {
    tenantType: string;
    tenantId: string;
    idpConnectionId: string;
}, RawHttpRequest$2, RawHttpRequest$3, RawHttpResponse$2 & RawHttpResponseNonNullableFields$2, RawHttpResponse$3 & RawHttpResponseNonNullableFields$3>;
declare function loginCallback(): __PublicMethodMetaInfo$6<'GET', {}, LoginCallbackRequest, LoginCallbackRequest$1, RawHttpResponse$2 & RawHttpResponseNonNullableFields$2, RawHttpResponse$3 & RawHttpResponseNonNullableFields$3>;
declare function loginWithIdpConnectionTokenParams(): __PublicMethodMetaInfo$6<'POST', {}, LoginWithIdpConnectionTokenParamsRequest, LoginWithIdpConnectionTokenParamsRequest$1, StateMachineResponse$4 & StateMachineResponseNonNullableFields$4, StateMachineResponse$5 & StateMachineResponseNonNullableFields$5>;
declare function signOn(): __PublicMethodMetaInfo$6<'POST', {}, SignOnRequest, SignOnRequest$1, SignOnResponse & SignOnResponseNonNullableFields, SignOnResponse$1 & SignOnResponseNonNullableFields$1>;
declare function logout(): __PublicMethodMetaInfo$6<'GET', {}, LogoutRequest, LogoutRequest$1, RawHttpResponse$2 & RawHttpResponseNonNullableFields$2, RawHttpResponse$3 & RawHttpResponseNonNullableFields$3>;

declare const meta$6_changePassword: typeof changePassword;
declare const meta$6_loginCallback: typeof loginCallback;
declare const meta$6_loginV2: typeof loginV2;
declare const meta$6_loginWithIdpConnection: typeof loginWithIdpConnection;
declare const meta$6_loginWithIdpConnectionCallback: typeof loginWithIdpConnectionCallback;
declare const meta$6_loginWithIdpConnectionTokenParams: typeof loginWithIdpConnectionTokenParams;
declare const meta$6_logout: typeof logout;
declare const meta$6_registerV2: typeof registerV2;
declare const meta$6_signOn: typeof signOn;
declare namespace meta$6 {
  export { type __PublicMethodMetaInfo$6 as __PublicMethodMetaInfo, meta$6_changePassword as changePassword, meta$6_loginCallback as loginCallback, meta$6_loginV2 as loginV2, meta$6_loginWithIdpConnection as loginWithIdpConnection, meta$6_loginWithIdpConnectionCallback as loginWithIdpConnectionCallback, meta$6_loginWithIdpConnectionTokenParams as loginWithIdpConnectionTokenParams, meta$6_logout as logout, meta$6_registerV2 as registerV2, meta$6_signOn as signOn };
}

interface SendRecoveryEmailRequest$1 {
    /** Email address associated with the account to recover. */
    email: string;
    /** Language of the email to be sent. Defaults to the language specified in the member's profile. */
    language?: string | null;
    /** Where to redirect to after a successful recovery. */
    redirect?: Redirect$1;
}
interface Redirect$1 {
    /** The URL to redirect to after a successful recovery. */
    url?: string;
    /** Caller identifier. */
    clientId?: string | null;
}
interface SendRecoveryEmailResponse$1 {
}
interface SendActivationEmailRequest$1 {
    /** Id of the activating user */
    identityId: string;
    /** Options for the activation email */
    emailOptions?: EmailOptions$1;
}
interface EmailOptions$1 {
    /** language of the email - if not received will fallback to the identity language */
    language?: string | null;
    /** Where to redirect after a successful activation process */
    redirect?: Redirect$1;
}
interface SendActivationEmailResponse$1 {
}
interface RecoverRequest$1 {
    /** recovery token */
    recoveryToken: string;
    /** new password to set for the identity */
    password?: string | null;
}
interface StateMachineResponse$3 {
    /** The current state of the login or registration process. */
    state?: StateType$3;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$3;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$3>;
}
declare enum StateType$3 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$3 {
    /** Identity ID */
    id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$3[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$3[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$3;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$3;
    /** Identity email address. */
    email?: Email$3;
    /** Identity's current status. */
    status?: StatusV2$3;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$3[];
}
interface Identifier$3 extends IdentifierValueOneOf$3 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$3 {
    email?: string;
    userName?: string;
}
interface Connection$3 extends ConnectionTypeOneOf$3 {
    /** IDP connection. */
    idpConnection?: IdpConnection$3;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$3;
}
/** @oneof */
interface ConnectionTypeOneOf$3 {
    /** IDP connection. */
    idpConnection?: IdpConnection$3;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$3;
}
interface IdpConnection$3 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$3 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile$3 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$3;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$3[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$3[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$3[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$3[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$3 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$3 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$3;
}
interface V1CustomValue$3 extends V1CustomValueValueOneOf$3 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$3;
    /** Map value. */
    mapValue?: V1MapValue$3;
}
/** @oneof */
interface V1CustomValueValueOneOf$3 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$3;
    /** Map value. */
    mapValue?: V1MapValue$3;
}
interface V1ListValue$3 {
    /** Custom value. */
    value?: V1CustomValue$3[];
}
interface V1MapValue$3 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$3>;
}
interface SecondaryEmail$3 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$3;
}
declare enum EmailTag$3 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$3 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$3;
}
declare enum PhoneTag$3 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$3 {
    /** Address. */
    address?: Address$3;
    /** Address tag. */
    tag?: AddressTag$3;
}
/** Physical address */
interface Address$3 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$3 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata$3 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$3 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$3 {
    name?: StatusName$3;
    reasons?: Reason$3[];
}
declare enum StatusName$3 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$3 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$3 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$3;
    /** Factor status. */
    status?: Status$3;
}
declare enum FactorType$3 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$3 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$3 extends CustomValueValueOneOf$3 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$3;
    /** Map value. */
    mapValue?: MapValue$3;
}
/** @oneof */
interface CustomValueValueOneOf$3 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$3;
    /** Map value. */
    mapValue?: MapValue$3;
}
interface ListValue$3 {
    /** Custom value. */
    value?: CustomValue$3[];
}
interface MapValue$3 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$3>;
}
interface IdentifierNonNullableFields$3 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$3 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$3 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$3 {
    idpConnection?: IdpConnectionNonNullableFields$3;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$3;
}
interface V1ListValueNonNullableFields$3 {
    value: V1CustomValueNonNullableFields$3[];
}
interface V1CustomValueNonNullableFields$3 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$3;
}
interface CustomFieldNonNullableFields$3 {
    name: string;
    value?: V1CustomValueNonNullableFields$3;
}
interface SecondaryEmailNonNullableFields$3 {
    email: string;
    tag: EmailTag$3;
}
interface PhoneNonNullableFields$3 {
    phone: string;
    tag: PhoneTag$3;
}
interface AddressWrapperNonNullableFields$3 {
    tag: AddressTag$3;
}
interface IdentityProfileNonNullableFields$3 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$3;
    customFields: CustomFieldNonNullableFields$3[];
    secondaryEmails: SecondaryEmailNonNullableFields$3[];
    phonesV2: PhoneNonNullableFields$3[];
    addresses: AddressWrapperNonNullableFields$3[];
}
interface MetadataNonNullableFields$3 {
    tags: string[];
}
interface EmailNonNullableFields$3 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$3 {
    name: StatusName$3;
    reasons: Reason$3[];
}
interface FactorNonNullableFields$3 {
    factorId: string;
    type: FactorType$3;
    status: Status$3;
}
interface IdentityNonNullableFields$3 {
    identifiers: IdentifierNonNullableFields$3[];
    connections: ConnectionNonNullableFields$3[];
    identityProfile?: IdentityProfileNonNullableFields$3;
    metadata?: MetadataNonNullableFields$3;
    email?: EmailNonNullableFields$3;
    status?: StatusV2NonNullableFields$3;
    factors: FactorNonNullableFields$3[];
}
interface StateMachineResponseNonNullableFields$3 {
    state: StateType$3;
    identity?: IdentityNonNullableFields$3;
}

interface SendRecoveryEmailRequest {
    /** Email address associated with the account to recover. */
    email: string;
    /** Language of the email to be sent. Defaults to the language specified in the member's profile. */
    language?: string | null;
    /** Where to redirect to after a successful recovery. */
    redirect?: Redirect;
}
interface Redirect {
    /** The URL to redirect to after a successful recovery. */
    url?: string;
    /** Caller identifier. */
    clientId?: string | null;
}
interface SendRecoveryEmailResponse {
}
interface SendActivationEmailRequest {
    /** Id of the activating user */
    identityId: string;
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
interface EmailOptions {
    /** language of the email - if not received will fallback to the identity language */
    language?: string | null;
    /** Where to redirect after a successful activation process */
    redirect?: Redirect;
}
interface SendActivationEmailResponse {
}
interface RecoverRequest {
    /** recovery token */
    recoveryToken: string;
    /** new password to set for the identity */
    password?: string | null;
}
interface StateMachineResponse$2 {
    /** The current state of the login or registration process. */
    state?: StateType$2;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$2;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$2>;
}
declare enum StateType$2 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$2 {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$2[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$2[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$2;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$2;
    /** Identity email address. */
    email?: Email$2;
    /** Identity's current status. */
    status?: StatusV2$2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$2[];
}
interface Identifier$2 extends IdentifierValueOneOf$2 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$2 {
    email?: string;
    userName?: string;
}
interface Connection$2 extends ConnectionTypeOneOf$2 {
    /** IDP connection. */
    idpConnection?: IdpConnection$2;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$2;
}
/** @oneof */
interface ConnectionTypeOneOf$2 {
    /** IDP connection. */
    idpConnection?: IdpConnection$2;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$2;
}
interface IdpConnection$2 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$2 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile$2 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$2;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$2[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$2[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$2[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$2[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$2 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$2 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$2;
}
interface V1CustomValue$2 extends V1CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$2;
    /** Map value. */
    mapValue?: V1MapValue$2;
}
/** @oneof */
interface V1CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$2;
    /** Map value. */
    mapValue?: V1MapValue$2;
}
interface V1ListValue$2 {
    /** Custom value. */
    value?: V1CustomValue$2[];
}
interface V1MapValue$2 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$2>;
}
interface SecondaryEmail$2 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$2;
}
declare enum EmailTag$2 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$2 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$2;
}
declare enum PhoneTag$2 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$2 {
    /** Address. */
    address?: Address$2;
    /** Address tag. */
    tag?: AddressTag$2;
}
/** Physical address */
interface Address$2 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$2 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata$2 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$2 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$2 {
    name?: StatusName$2;
    reasons?: Reason$2[];
}
declare enum StatusName$2 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$2 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$2 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$2;
    /** Factor status. */
    status?: Status$2;
}
declare enum FactorType$2 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$2 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$2 extends CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$2;
    /** Map value. */
    mapValue?: MapValue$2;
}
/** @oneof */
interface CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$2;
    /** Map value. */
    mapValue?: MapValue$2;
}
interface ListValue$2 {
    /** Custom value. */
    value?: CustomValue$2[];
}
interface MapValue$2 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$2>;
}
interface IdentifierNonNullableFields$2 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$2 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$2 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$2 {
    idpConnection?: IdpConnectionNonNullableFields$2;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$2;
}
interface V1ListValueNonNullableFields$2 {
    value: V1CustomValueNonNullableFields$2[];
}
interface V1CustomValueNonNullableFields$2 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$2;
}
interface CustomFieldNonNullableFields$2 {
    name: string;
    value?: V1CustomValueNonNullableFields$2;
}
interface SecondaryEmailNonNullableFields$2 {
    email: string;
    tag: EmailTag$2;
}
interface PhoneNonNullableFields$2 {
    phone: string;
    tag: PhoneTag$2;
}
interface AddressWrapperNonNullableFields$2 {
    tag: AddressTag$2;
}
interface IdentityProfileNonNullableFields$2 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$2;
    customFields: CustomFieldNonNullableFields$2[];
    secondaryEmails: SecondaryEmailNonNullableFields$2[];
    phonesV2: PhoneNonNullableFields$2[];
    addresses: AddressWrapperNonNullableFields$2[];
}
interface MetadataNonNullableFields$2 {
    tags: string[];
}
interface EmailNonNullableFields$2 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$2 {
    name: StatusName$2;
    reasons: Reason$2[];
}
interface FactorNonNullableFields$2 {
    factorId: string;
    type: FactorType$2;
    status: Status$2;
}
interface IdentityNonNullableFields$2 {
    identifiers: IdentifierNonNullableFields$2[];
    connections: ConnectionNonNullableFields$2[];
    identityProfile?: IdentityProfileNonNullableFields$2;
    metadata?: MetadataNonNullableFields$2;
    email?: EmailNonNullableFields$2;
    status?: StatusV2NonNullableFields$2;
    factors: FactorNonNullableFields$2[];
}
interface StateMachineResponseNonNullableFields$2 {
    state: StateType$2;
    identity?: IdentityNonNullableFields$2;
}

type __PublicMethodMetaInfo$5<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function sendRecoveryEmail(): __PublicMethodMetaInfo$5<'POST', {}, SendRecoveryEmailRequest, SendRecoveryEmailRequest$1, SendRecoveryEmailResponse, SendRecoveryEmailResponse$1>;
declare function sendActivationEmail(): __PublicMethodMetaInfo$5<'POST', {}, SendActivationEmailRequest, SendActivationEmailRequest$1, SendActivationEmailResponse, SendActivationEmailResponse$1>;
declare function recover(): __PublicMethodMetaInfo$5<'POST', {}, RecoverRequest, RecoverRequest$1, StateMachineResponse$2 & StateMachineResponseNonNullableFields$2, StateMachineResponse$3 & StateMachineResponseNonNullableFields$3>;

declare const meta$5_recover: typeof recover;
declare const meta$5_sendActivationEmail: typeof sendActivationEmail;
declare const meta$5_sendRecoveryEmail: typeof sendRecoveryEmail;
declare namespace meta$5 {
  export { type __PublicMethodMetaInfo$5 as __PublicMethodMetaInfo, meta$5_recover as recover, meta$5_sendActivationEmail as sendActivationEmail, meta$5_sendRecoveryEmail as sendRecoveryEmail };
}

interface StartResponse$1 {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest$1 {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target$1;
}
declare enum Target$1 {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
interface VerifyDuringAuthenticationRequest$1 {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse$1 {
    /** The current state of the login or registration process. */
    state?: StateType$1;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$1;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$1>;
}
declare enum StateType$1 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$1 {
    /** Identity ID */
    id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$1[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$1[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$1;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$1;
    /** Identity email address. */
    email?: Email$1;
    /** Identity's current status. */
    status?: StatusV2$1;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$1[];
}
interface Identifier$1 extends IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
interface Connection$1 extends ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
/** @oneof */
interface ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
interface IdpConnection$1 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$1 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile$1 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$1;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$1[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$1[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$1[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$1[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$1 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$1 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$1;
}
interface V1CustomValue$1 extends V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
/** @oneof */
interface V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
interface V1ListValue$1 {
    /** Custom value. */
    value?: V1CustomValue$1[];
}
interface V1MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$1>;
}
interface SecondaryEmail$1 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$1;
}
declare enum EmailTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$1 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$1;
}
declare enum PhoneTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$1 {
    /** Address. */
    address?: Address$1;
    /** Address tag. */
    tag?: AddressTag$1;
}
/** Physical address */
interface Address$1 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$1 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata$1 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$1 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$1 {
    name?: StatusName$1;
    reasons?: Reason$1[];
}
declare enum StatusName$1 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$1 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$1 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$1;
    /** Factor status. */
    status?: Status$1;
}
declare enum FactorType$1 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$1 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$1 extends CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
/** @oneof */
interface CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
interface ListValue$1 {
    /** Custom value. */
    value?: CustomValue$1[];
}
interface MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$1>;
}
interface ResendDuringAuthenticationRequest$1 {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StartResponseNonNullableFields$1 {
    verificationId: string;
}
interface IdentifierNonNullableFields$1 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$1 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$1 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$1 {
    idpConnection?: IdpConnectionNonNullableFields$1;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$1;
}
interface V1ListValueNonNullableFields$1 {
    value: V1CustomValueNonNullableFields$1[];
}
interface V1CustomValueNonNullableFields$1 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$1;
}
interface CustomFieldNonNullableFields$1 {
    name: string;
    value?: V1CustomValueNonNullableFields$1;
}
interface SecondaryEmailNonNullableFields$1 {
    email: string;
    tag: EmailTag$1;
}
interface PhoneNonNullableFields$1 {
    phone: string;
    tag: PhoneTag$1;
}
interface AddressWrapperNonNullableFields$1 {
    tag: AddressTag$1;
}
interface IdentityProfileNonNullableFields$1 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$1;
    customFields: CustomFieldNonNullableFields$1[];
    secondaryEmails: SecondaryEmailNonNullableFields$1[];
    phonesV2: PhoneNonNullableFields$1[];
    addresses: AddressWrapperNonNullableFields$1[];
}
interface MetadataNonNullableFields$1 {
    tags: string[];
}
interface EmailNonNullableFields$1 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$1 {
    name: StatusName$1;
    reasons: Reason$1[];
}
interface FactorNonNullableFields$1 {
    factorId: string;
    type: FactorType$1;
    status: Status$1;
}
interface IdentityNonNullableFields$1 {
    identifiers: IdentifierNonNullableFields$1[];
    connections: ConnectionNonNullableFields$1[];
    identityProfile?: IdentityProfileNonNullableFields$1;
    metadata?: MetadataNonNullableFields$1;
    email?: EmailNonNullableFields$1;
    status?: StatusV2NonNullableFields$1;
    factors: FactorNonNullableFields$1[];
}
interface StateMachineResponseNonNullableFields$1 {
    state: StateType$1;
    identity?: IdentityNonNullableFields$1;
}

interface StartResponse {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target;
}
declare enum Target {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
interface VerifyDuringAuthenticationRequest {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse {
    /** The current state of the login or registration process. */
    state?: StateType;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue>;
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor[];
}
interface Identifier extends IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
declare enum FactorType {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface ResendDuringAuthenticationRequest {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StartResponseNonNullableFields {
    verificationId: string;
}
interface IdentifierNonNullableFields {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    identifiers: IdentifierNonNullableFields[];
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
interface StateMachineResponseNonNullableFields {
    state: StateType;
    identity?: IdentityNonNullableFields;
}

type __PublicMethodMetaInfo$4<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function start(): __PublicMethodMetaInfo$4<'POST', {}, StartRequest, StartRequest$1, StartResponse & StartResponseNonNullableFields, StartResponse$1 & StartResponseNonNullableFields$1>;
declare function verifyDuringAuthentication(): __PublicMethodMetaInfo$4<'POST', {}, VerifyDuringAuthenticationRequest, VerifyDuringAuthenticationRequest$1, StateMachineResponse & StateMachineResponseNonNullableFields, StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;
declare function resendDuringAuthentication(): __PublicMethodMetaInfo$4<'POST', {}, ResendDuringAuthenticationRequest, ResendDuringAuthenticationRequest$1, StateMachineResponse & StateMachineResponseNonNullableFields, StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;

declare const meta$4_resendDuringAuthentication: typeof resendDuringAuthentication;
declare const meta$4_start: typeof start;
declare const meta$4_verifyDuringAuthentication: typeof verifyDuringAuthentication;
declare namespace meta$4 {
  export { type __PublicMethodMetaInfo$4 as __PublicMethodMetaInfo, meta$4_resendDuringAuthentication as resendDuringAuthentication, meta$4_start as start, meta$4_verifyDuringAuthentication as verifyDuringAuthentication };
}

interface AccountInvite$1 {
    /**
     * Invite ID.
     * @readonly
     */
    id?: string;
    /**
     * Account ID.
     * @readonly
     */
    accountId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /**
     * Deprecated. Use `policyIds`.
     * @deprecated
     */
    role?: string;
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user has declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus$3;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /** Date the invite was last updated. */
    dateUpdated?: Date | null;
    /** Assets the users are invited to join. */
    assignments?: InviteResourceAssignment$1[];
    /** Invite expiration date. */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus$3 {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface InviteResourceAssignment$1 {
    /** Role ID. */
    policyId?: string;
    /** Resources the user will be able to access. */
    assignments?: InviteAssignment$1[];
}
interface InviteAssignment$1 {
    /** Full name of resource to be assigned. */
    fullNameResource?: FullNameResource$1;
}
interface FullNameResource$1 extends FullNameResourceResourceContextOneOf$1 {
    /** Specific site details. */
    siteContext?: SiteResourceContext$1;
    /** Specific account details. */
    accountContext?: AccountResourceContext$1;
}
/** @oneof */
interface FullNameResourceResourceContextOneOf$1 {
    /** Specific site details. */
    siteContext?: SiteResourceContext$1;
    /** Specific account details. */
    accountContext?: AccountResourceContext$1;
}
/** Site resource context. It indicates that the resource is under a site (can be the site itself or some asset of a site, like a blog post) */
interface SiteResourceContext$1 {
    /** Site ID. */
    metasiteId?: string;
}
/** Account resource contexts. It indicates that the resource is under the account (can be the account itself or some asset of an account, like a logo or a domain) */
interface AccountResourceContext$1 {
    /** Account ID. */
    accountId?: string;
}
declare enum SimpleConditionOperator$1 {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
declare enum JoinedConditionOperator$1 {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
declare enum SubjectType$3 {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
declare enum SubjectContextType$1 {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface CreateInviteRequest$1 {
    /** Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite). */
    subjectsAssignments: SubjectInviteAssignments$1[];
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface SubjectInviteAssignments$1 {
    /** Invitee's email address. */
    subjectEmail?: string;
    /** Mapping of roles (referred to here as policies) and assets (referred to here as resources) that will be assigned to the invitee when they accept the invite. When no resources are specified, the invitee will be given access to everything within the account. */
    assignments?: InviteResourceAssignment$1[];
}
interface CreateInviteResponse$1 {
    /** Invites that were sent successfully. */
    successfulInvites?: AccountInvite$1[];
    /** Invites that failed. */
    failedInvites?: InviteFailure$1[];
}
interface InviteFailure$1 {
    /** Email address of the failed invite. */
    subjectEmail?: string;
    /** Error description. */
    errorMessage?: string;
}
interface SiteResourceContextNonNullableFields$1 {
    metasiteId: string;
}
interface AccountResourceContextNonNullableFields$1 {
    accountId: string;
}
interface FullNameResourceNonNullableFields$1 {
    siteContext?: SiteResourceContextNonNullableFields$1;
    accountContext?: AccountResourceContextNonNullableFields$1;
}
interface SimpleConditionValueNonNullableFields$1 {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface SimpleConditionNonNullableFields$1 {
    attrName: string;
    value?: SimpleConditionValueNonNullableFields$1;
    op: SimpleConditionOperator$1;
    conditionModelId: string;
}
interface JoinedConditionNonNullableFields$1 {
    op: JoinedConditionOperator$1;
    conditions: ConditionTypeNonNullableFields$1[];
}
interface ExperimentConditionNonNullableFields$1 {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface EnvironmentConditionNonNullableFields$1 {
    experimentCondition?: ExperimentConditionNonNullableFields$1;
}
interface ConditionValueNonNullableFields$1 {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface EqualOperatorNonNullableFields$1 {
    attrName: string;
    value?: ConditionValueNonNullableFields$1;
}
interface LikeOperatorNonNullableFields$1 {
    attrName: string;
    values: string[];
}
interface ExperimentOperatorNonNullableFields$1 {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface SubjectContextNonNullableFields$1 {
    id: string;
    contextType: SubjectContextType$1;
}
interface SubjectNonNullableFields$1 {
    id: string;
    subjectType: SubjectType$3;
    context?: SubjectContextNonNullableFields$1;
}
interface DependOnOperatorNonNullableFields$1 {
    dependOnSubject?: SubjectNonNullableFields$1;
}
interface ConditionOperatorNonNullableFields$1 {
    equals?: EqualOperatorNonNullableFields$1;
    like?: LikeOperatorNonNullableFields$1;
    experiment?: ExperimentOperatorNonNullableFields$1;
    dependOn?: DependOnOperatorNonNullableFields$1;
}
interface ConditionNonNullableFields$1 {
    conditionModelId: string;
    operator?: ConditionOperatorNonNullableFields$1;
}
interface ConditionTypeNonNullableFields$1 {
    simpleCondition?: SimpleConditionNonNullableFields$1;
    joinedConditions?: JoinedConditionNonNullableFields$1;
    environmentCondition?: EnvironmentConditionNonNullableFields$1;
    condition?: ConditionNonNullableFields$1;
}
interface PolicyConditionNonNullableFields$1 {
    condition?: ConditionTypeNonNullableFields$1;
}
interface InviteAssignmentNonNullableFields$1 {
    fullNameResource?: FullNameResourceNonNullableFields$1;
    condition?: PolicyConditionNonNullableFields$1;
}
interface InviteResourceAssignmentNonNullableFields$1 {
    policyId: string;
    assignments: InviteAssignmentNonNullableFields$1[];
}
interface AccountInviteNonNullableFields$1 {
    id: string;
    accountId: string;
    email: string;
    role: string;
    inviterId: string;
    status: InviteStatus$3;
    acceptLink: string;
    inviterAccountId: string;
    policyIds: string[];
    assignments: InviteResourceAssignmentNonNullableFields$1[];
}
interface InviteFailureNonNullableFields$1 {
    subjectEmail: string;
    errorMessage: string;
}
interface CreateInviteResponseNonNullableFields$1 {
    successfulInvites: AccountInviteNonNullableFields$1[];
    failedInvites: InviteFailureNonNullableFields$1[];
}

interface AccountInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Account ID.
     * @readonly
     */
    accountId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /**
     * Deprecated. Use `policyIds`.
     * @deprecated
     */
    role?: string;
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user has declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus$2;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /** Date the invite was last updated. */
    dateUpdated?: Date | null;
    /** Assets the users are invited to join. */
    assignments?: InviteResourceAssignment[];
    /** Invite expiration date. */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus$2 {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface InviteResourceAssignment {
    /** Role ID. */
    policyId?: string;
    /** Resources the user will be able to access. */
    assignments?: InviteAssignment[];
}
interface InviteAssignment {
    /** Full name of resource to be assigned. */
    fullNameResource?: FullNameResource;
}
interface FullNameResource extends FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** @oneof */
interface FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** Site resource context. It indicates that the resource is under a site (can be the site itself or some asset of a site, like a blog post) */
interface SiteResourceContext {
    /** Site ID. */
    metasiteId?: string;
}
/** Account resource contexts. It indicates that the resource is under the account (can be the account itself or some asset of an account, like a logo or a domain) */
interface AccountResourceContext {
    /** Account ID. */
    accountId?: string;
}
declare enum SimpleConditionOperator {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
declare enum JoinedConditionOperator {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
declare enum SubjectType$2 {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface CreateInviteRequest {
    /** Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite). */
    subjectsAssignments: SubjectInviteAssignments[];
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface SubjectInviteAssignments {
    /** Invitee's email address. */
    subjectEmail?: string;
    /** Mapping of roles (referred to here as policies) and assets (referred to here as resources) that will be assigned to the invitee when they accept the invite. When no resources are specified, the invitee will be given access to everything within the account. */
    assignments?: InviteResourceAssignment[];
}
interface CreateInviteResponse {
    /** Invites that were sent successfully. */
    successfulInvites?: AccountInvite[];
    /** Invites that failed. */
    failedInvites?: InviteFailure[];
}
interface InviteFailure {
    /** Email address of the failed invite. */
    subjectEmail?: string;
    /** Error description. */
    errorMessage?: string;
}
interface SiteResourceContextNonNullableFields {
    metasiteId: string;
}
interface AccountResourceContextNonNullableFields {
    accountId: string;
}
interface FullNameResourceNonNullableFields {
    siteContext?: SiteResourceContextNonNullableFields;
    accountContext?: AccountResourceContextNonNullableFields;
}
interface SimpleConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface SimpleConditionNonNullableFields {
    attrName: string;
    value?: SimpleConditionValueNonNullableFields;
    op: SimpleConditionOperator;
    conditionModelId: string;
}
interface JoinedConditionNonNullableFields {
    op: JoinedConditionOperator;
    conditions: ConditionTypeNonNullableFields[];
}
interface ExperimentConditionNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface EnvironmentConditionNonNullableFields {
    experimentCondition?: ExperimentConditionNonNullableFields;
}
interface ConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface EqualOperatorNonNullableFields {
    attrName: string;
    value?: ConditionValueNonNullableFields;
}
interface LikeOperatorNonNullableFields {
    attrName: string;
    values: string[];
}
interface ExperimentOperatorNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface SubjectContextNonNullableFields {
    _id: string;
    contextType: SubjectContextType;
}
interface SubjectNonNullableFields {
    _id: string;
    subjectType: SubjectType$2;
    context?: SubjectContextNonNullableFields;
}
interface DependOnOperatorNonNullableFields {
    dependOnSubject?: SubjectNonNullableFields;
}
interface ConditionOperatorNonNullableFields {
    equals?: EqualOperatorNonNullableFields;
    like?: LikeOperatorNonNullableFields;
    experiment?: ExperimentOperatorNonNullableFields;
    dependOn?: DependOnOperatorNonNullableFields;
}
interface ConditionNonNullableFields {
    conditionModelId: string;
    operator?: ConditionOperatorNonNullableFields;
}
interface ConditionTypeNonNullableFields {
    simpleCondition?: SimpleConditionNonNullableFields;
    joinedConditions?: JoinedConditionNonNullableFields;
    environmentCondition?: EnvironmentConditionNonNullableFields;
    condition?: ConditionNonNullableFields;
}
interface PolicyConditionNonNullableFields {
    condition?: ConditionTypeNonNullableFields;
}
interface InviteAssignmentNonNullableFields {
    fullNameResource?: FullNameResourceNonNullableFields;
    condition?: PolicyConditionNonNullableFields;
}
interface InviteResourceAssignmentNonNullableFields {
    policyId: string;
    assignments: InviteAssignmentNonNullableFields[];
}
interface AccountInviteNonNullableFields {
    _id: string;
    accountId: string;
    email: string;
    role: string;
    inviterId: string;
    status: InviteStatus$2;
    acceptLink: string;
    inviterAccountId: string;
    policyIds: string[];
    assignments: InviteResourceAssignmentNonNullableFields[];
}
interface InviteFailureNonNullableFields {
    subjectEmail: string;
    errorMessage: string;
}
interface CreateInviteResponseNonNullableFields {
    successfulInvites: AccountInviteNonNullableFields[];
    failedInvites: InviteFailureNonNullableFields[];
}

type __PublicMethodMetaInfo$3<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createInvite(): __PublicMethodMetaInfo$3<'POST', {}, CreateInviteRequest, CreateInviteRequest$1, CreateInviteResponse & CreateInviteResponseNonNullableFields, CreateInviteResponse$1 & CreateInviteResponseNonNullableFields$1>;

declare const meta$3_createInvite: typeof createInvite;
declare namespace meta$3 {
  export { type __PublicMethodMetaInfo$3 as __PublicMethodMetaInfo, meta$3_createInvite as createInvite };
}

interface SiteInvite$1 {
    /**
     * Invite ID.
     * @readonly
     */
    id?: string;
    /**
     * Site ID the user is invited to as a collaborator.
     * @readonly
     */
    siteId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite Status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus$1;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** User's Wix Bookings staff ID, if relevant. */
    staffId?: string | null;
    /** Invite expiration date */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus$1 {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface SiteInviteResponse$1 {
    /** Invites that were sent. */
    invite?: SiteInvite$1;
}
interface BulkSiteInviteRequest$1 {
    /** Role IDs, referred to as policy IDs, to assign to the contributors. */
    policyIds: string[];
    /** Email addresses to which the invites should be sent. */
    emails: string[];
    /** Details explaining the purpose of the invite. */
    invitePurpose?: string | null;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface BulkSiteInviteResponse$1 {
    /** Invites that were sent successfully. */
    invites?: SiteInvite$1[];
    /** Invites that failed. */
    failedEmails?: string[];
}
interface ResendSiteInviteRequest$1 {
    /** Invite ID. */
    inviteId: string;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface RevokeSiteInviteRequest$1 {
    /** Invite ID. */
    inviteId: string;
}
interface RevokeSiteInviteResponse$1 {
}
interface SiteInviteNonNullableFields$1 {
    id: string;
    siteId: string;
    email: string;
    policyIds: string[];
    inviterId: string;
    status: InviteStatus$1;
    acceptLink: string;
    inviterAccountId: string;
}
interface BulkSiteInviteResponseNonNullableFields$1 {
    invites: SiteInviteNonNullableFields$1[];
    failedEmails: string[];
}
interface SiteInviteResponseNonNullableFields$1 {
    invite?: SiteInviteNonNullableFields$1;
}

interface SiteInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Site ID the user is invited to as a collaborator.
     * @readonly
     */
    siteId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite Status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** User's Wix Bookings staff ID, if relevant. */
    staffId?: string | null;
    /** Invite expiration date */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface SiteInviteResponse {
    /** Invites that were sent. */
    invite?: SiteInvite;
}
interface BulkSiteInviteRequest {
    /** Role IDs, referred to as policy IDs, to assign to the contributors. */
    policyIds: string[];
    /** Email addresses to which the invites should be sent. */
    emails: string[];
    /** Details explaining the purpose of the invite. */
    invitePurpose?: string | null;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface BulkSiteInviteResponse {
    /** Invites that were sent successfully. */
    invites?: SiteInvite[];
    /** Invites that failed. */
    failedEmails?: string[];
}
interface ResendSiteInviteRequest {
    /** Invite ID. */
    inviteId: string;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface RevokeSiteInviteRequest {
    /** Invite ID. */
    inviteId: string;
}
interface RevokeSiteInviteResponse {
}
interface SiteInviteNonNullableFields {
    _id: string;
    siteId: string;
    email: string;
    policyIds: string[];
    inviterId: string;
    status: InviteStatus;
    acceptLink: string;
    inviterAccountId: string;
}
interface BulkSiteInviteResponseNonNullableFields {
    invites: SiteInviteNonNullableFields[];
    failedEmails: string[];
}
interface SiteInviteResponseNonNullableFields {
    invite?: SiteInviteNonNullableFields;
}

type __PublicMethodMetaInfo$2<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function bulkInvite(): __PublicMethodMetaInfo$2<'POST', {}, BulkSiteInviteRequest, BulkSiteInviteRequest$1, BulkSiteInviteResponse & BulkSiteInviteResponseNonNullableFields, BulkSiteInviteResponse$1 & BulkSiteInviteResponseNonNullableFields$1>;
declare function resendInvite(): __PublicMethodMetaInfo$2<'POST', {
    inviteId: string;
}, ResendSiteInviteRequest, ResendSiteInviteRequest$1, SiteInviteResponse & SiteInviteResponseNonNullableFields, SiteInviteResponse$1 & SiteInviteResponseNonNullableFields$1>;
declare function revokeInvite(): __PublicMethodMetaInfo$2<'POST', {
    inviteId: string;
}, RevokeSiteInviteRequest, RevokeSiteInviteRequest$1, RevokeSiteInviteResponse, RevokeSiteInviteResponse$1>;

declare const meta$2_bulkInvite: typeof bulkInvite;
declare const meta$2_resendInvite: typeof resendInvite;
declare const meta$2_revokeInvite: typeof revokeInvite;
declare namespace meta$2 {
  export { type __PublicMethodMetaInfo$2 as __PublicMethodMetaInfo, meta$2_bulkInvite as bulkInvite, meta$2_resendInvite as resendInvite, meta$2_revokeInvite as revokeInvite };
}

interface RawHttpResponse$1 {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry$1[];
}
interface HeadersEntry$1 {
    key?: string;
    value?: string;
}
interface RawHttpRequest$1 {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$1[];
    queryParams?: QueryParametersEntry$1[];
    headers?: HeadersEntry$1[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry$1 {
    key?: string;
    value?: string;
}
interface QueryParametersEntry$1 {
    key?: string;
    value?: string;
}
interface TokenInfoResponse$1 {
    active?: boolean;
    /** subject type. */
    subjectType?: SubjectType$1;
    /** subject id */
    subjectId?: string;
    /** Expiration time of the token */
    exp?: string | null;
    /** Issued time of the token */
    iat?: string | null;
    /** Client id */
    clientId?: string;
    /** Account id */
    accountId?: string | null;
    /** Site id */
    siteId?: string | null;
    /** Instance Id */
    instanceId?: string | null;
    /** Vendor Product Id */
    vendorProductId?: string | null;
}
declare enum SubjectType$1 {
    /** unknown subject type */
    UNKNOWN = "UNKNOWN",
    /** user subject type */
    USER = "USER",
    /** visitor subject type */
    VISITOR = "VISITOR",
    /** member subject type */
    MEMBER = "MEMBER",
    /** app subject type */
    APP = "APP"
}
interface HeadersEntryNonNullableFields$1 {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields$1 {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields$1[];
}
interface TokenInfoResponseNonNullableFields$1 {
    active: boolean;
    subjectType: SubjectType$1;
    subjectId: string;
    clientId: string;
}

interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface TokenInfoResponse {
    active?: boolean;
    /** subject type. */
    subjectType?: SubjectType;
    /** subject id */
    subjectId?: string;
    /** Expiration time of the token */
    exp?: string | null;
    /** Issued time of the token */
    iat?: string | null;
    /** Client id */
    clientId?: string;
    /** Account id */
    accountId?: string | null;
    /** Site id */
    siteId?: string | null;
    /** Instance Id */
    instanceId?: string | null;
    /** Vendor Product Id */
    vendorProductId?: string | null;
}
declare enum SubjectType {
    /** unknown subject type */
    UNKNOWN = "UNKNOWN",
    /** user subject type */
    USER = "USER",
    /** visitor subject type */
    VISITOR = "VISITOR",
    /** member subject type */
    MEMBER = "MEMBER",
    /** app subject type */
    APP = "APP"
}
interface HeadersEntryNonNullableFields {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields[];
}
interface TokenInfoResponseNonNullableFields {
    active: boolean;
    subjectType: SubjectType;
    subjectId: string;
    clientId: string;
}

type __PublicMethodMetaInfo$1<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function token(): __PublicMethodMetaInfo$1<'POST', {}, RawHttpRequest, RawHttpRequest$1, RawHttpResponse & RawHttpResponseNonNullableFields, RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
declare function tokenInfo(): __PublicMethodMetaInfo$1<'POST', {}, RawHttpRequest, RawHttpRequest$1, TokenInfoResponse & TokenInfoResponseNonNullableFields, TokenInfoResponse$1 & TokenInfoResponseNonNullableFields$1>;

declare const meta$1_token: typeof token;
declare const meta$1_tokenInfo: typeof tokenInfo;
declare namespace meta$1 {
  export { type __PublicMethodMetaInfo$1 as __PublicMethodMetaInfo, meta$1_token as token, meta$1_tokenInfo as tokenInfo };
}

interface ChangeContributorRoleRequest$1 {
    /** Contributor's account ID. */
    accountId: string;
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment$1[];
}
interface SiteRoleAssignment$1 {
    /** Role ID. Sometimes referred to as policy ID. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for a list of available roles. */
    roleId?: string;
    /**
     * Assignment ID mapping the role to the contributor on the site.
     * @readonly
     */
    assignmentId?: string;
}
interface ChangeContributorRoleResponse$1 {
    /** New roles assigned to the contributor on the site. */
    newAssignedRoles?: SiteRoleAssignment$1[];
}
interface QuerySiteContributorsRequest$1 {
    filter?: QuerySiteContributorsFilter$1;
}
interface QuerySiteContributorsFilter$1 {
    /** Role IDs (referred to here as policy IDs) to return. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for available roles. */
    policyIds?: string[];
}
interface QuerySiteContributorsResponse$1 {
    /** List of site contributors. */
    contributors?: ContributorV2$1[];
}
interface ContributorV2$1 {
    /** Contributor's account ID. */
    accountId?: string | null;
    /** User ID of the owner of the account that the contributor has joined. */
    accountOwnerId?: string | null;
}
interface SiteRoleAssignmentNonNullableFields$1 {
    roleId: string;
    assignmentId: string;
}
interface ChangeContributorRoleResponseNonNullableFields$1 {
    newAssignedRoles: SiteRoleAssignmentNonNullableFields$1[];
}

interface ChangeContributorRoleRequest {
    /** Contributor's account ID. */
    accountId: string;
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment[];
}
interface SiteRoleAssignment {
    /** Role ID. Sometimes referred to as policy ID. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for a list of available roles. */
    roleId?: string;
    /**
     * Assignment ID mapping the role to the contributor on the site.
     * @readonly
     */
    assignmentId?: string;
}
interface ChangeContributorRoleResponse {
    /** New roles assigned to the contributor on the site. */
    newAssignedRoles?: SiteRoleAssignment[];
}
interface QuerySiteContributorsRequest {
    filter?: QuerySiteContributorsFilter;
}
interface QuerySiteContributorsFilter {
    /** Role IDs (referred to here as policy IDs) to return. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for available roles. */
    policyIds?: string[];
}
interface QuerySiteContributorsResponse {
    /** List of site contributors. */
    contributors?: ContributorV2[];
}
interface ContributorV2 {
    /** Contributor's account ID. */
    accountId?: string | null;
    /** User ID of the owner of the account that the contributor has joined. */
    accountOwnerId?: string | null;
}
interface SiteRoleAssignmentNonNullableFields {
    roleId: string;
    assignmentId: string;
}
interface ChangeContributorRoleResponseNonNullableFields {
    newAssignedRoles: SiteRoleAssignmentNonNullableFields[];
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function changeRole(): __PublicMethodMetaInfo<'PUT', {}, ChangeContributorRoleRequest, ChangeContributorRoleRequest$1, ChangeContributorRoleResponse & ChangeContributorRoleResponseNonNullableFields, ChangeContributorRoleResponse$1 & ChangeContributorRoleResponseNonNullableFields$1>;
declare function querySiteContributors(): __PublicMethodMetaInfo<'GET', {}, QuerySiteContributorsRequest, QuerySiteContributorsRequest$1, QuerySiteContributorsResponse, QuerySiteContributorsResponse$1>;

type meta___PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = __PublicMethodMetaInfo<K, M, T, S, Q, R>;
declare const meta_changeRole: typeof changeRole;
declare const meta_querySiteContributors: typeof querySiteContributors;
declare namespace meta {
  export { type meta___PublicMethodMetaInfo as __PublicMethodMetaInfo, meta_changeRole as changeRole, meta_querySiteContributors as querySiteContributors };
}

export { meta$3 as accountInvite, meta$6 as authentication, meta$1 as oauth, meta$5 as recovery, meta as rolesManagement, meta$2 as siteInvite, meta$4 as verification };
