type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface Authentication {
}
interface RegisterV2Request {
    /** Identifier of registering member. */
    loginId: LoginId;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile$2;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId extends LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile$2 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$2;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$2[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$2[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$2[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$2[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$2 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$2 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$2;
}
interface V1CustomValue$2 extends V1CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$2;
    /** Map value. */
    mapValue?: V1MapValue$2;
}
/** @oneof */
interface V1CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$2;
    /** Map value. */
    mapValue?: V1MapValue$2;
}
interface V1ListValue$2 {
    /** Custom value. */
    value?: V1CustomValue$2[];
}
interface V1MapValue$2 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$2>;
}
interface SecondaryEmail$2 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$2;
}
declare enum EmailTag$2 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$2 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$2;
}
declare enum PhoneTag$2 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$2 {
    /** Address. */
    address?: Address$2;
    /** Address tag. */
    tag?: AddressTag$2;
}
/** Physical address */
interface Address$2 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$2 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken extends CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse$2 {
    /** The current state of the login or registration process. */
    state?: StateType$2;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$2;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$2>;
}
declare enum StateType$2 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$2 {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$2[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$2[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$2;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$2;
    /** Identity email address. */
    email?: Email$2;
    /** Identity's current status. */
    status?: StatusV2$2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$2[];
}
interface Identifier$2 extends IdentifierValueOneOf$2 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$2 {
    email?: string;
    userName?: string;
}
interface Connection$2 extends ConnectionTypeOneOf$2 {
    /** IDP connection. */
    idpConnection?: IdpConnection$2;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$2;
}
/** @oneof */
interface ConnectionTypeOneOf$2 {
    /** IDP connection. */
    idpConnection?: IdpConnection$2;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$2;
}
interface IdpConnection$2 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$2 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata$2 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$2 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$2 {
    name?: StatusName$2;
    reasons?: Reason$2[];
}
declare enum StatusName$2 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$2 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$2 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$2;
    /** Factor status. */
    status?: Status$2;
}
declare enum FactorType$2 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$2 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$2 extends CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$2;
    /** Map value. */
    mapValue?: MapValue$2;
}
/** @oneof */
interface CustomValueValueOneOf$2 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$2;
    /** Map value. */
    mapValue?: MapValue$2;
}
interface ListValue$2 {
    /** Custom value. */
    value?: CustomValue$2[];
}
interface MapValue$2 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$2>;
}
interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse {
}
interface LoginWithIdpConnectionRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType$1;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType$1 {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse$1 {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry$1[];
}
interface HeadersEntry$1 {
    key?: string;
    value?: string;
}
interface RawHttpRequest$1 {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$1[];
    queryParams?: QueryParametersEntry$1[];
    headers?: HeadersEntry$1[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry$1 {
    key?: string;
    value?: string;
}
interface QueryParametersEntry$1 {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile$2;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity$2;
}
/** logout request payload */
interface LogoutRequest {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields$2 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$2 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$2 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$2 {
    idpConnection?: IdpConnectionNonNullableFields$2;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$2;
}
interface V1ListValueNonNullableFields$2 {
    value: V1CustomValueNonNullableFields$2[];
}
interface V1CustomValueNonNullableFields$2 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$2;
}
interface CustomFieldNonNullableFields$2 {
    name: string;
    value?: V1CustomValueNonNullableFields$2;
}
interface SecondaryEmailNonNullableFields$2 {
    email: string;
    tag: EmailTag$2;
}
interface PhoneNonNullableFields$2 {
    phone: string;
    tag: PhoneTag$2;
}
interface AddressWrapperNonNullableFields$2 {
    tag: AddressTag$2;
}
interface IdentityProfileNonNullableFields$2 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$2;
    customFields: CustomFieldNonNullableFields$2[];
    secondaryEmails: SecondaryEmailNonNullableFields$2[];
    phonesV2: PhoneNonNullableFields$2[];
    addresses: AddressWrapperNonNullableFields$2[];
}
interface MetadataNonNullableFields$2 {
    tags: string[];
}
interface EmailNonNullableFields$2 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$2 {
    name: StatusName$2;
    reasons: Reason$2[];
}
interface FactorNonNullableFields$2 {
    factorId: string;
    type: FactorType$2;
    status: Status$2;
}
interface IdentityNonNullableFields$2 {
    identifiers: IdentifierNonNullableFields$2[];
    connections: ConnectionNonNullableFields$2[];
    identityProfile?: IdentityProfileNonNullableFields$2;
    metadata?: MetadataNonNullableFields$2;
    email?: EmailNonNullableFields$2;
    status?: StatusV2NonNullableFields$2;
    factors: FactorNonNullableFields$2[];
}
interface StateMachineResponseNonNullableFields$2 {
    state: StateType$2;
    identity?: IdentityNonNullableFields$2;
}
interface HeadersEntryNonNullableFields$1 {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields$1 {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields$1[];
}
interface SignOnResponseNonNullableFields {
    sessionToken: string;
    identity?: IdentityNonNullableFields$2;
}
interface RegisterV2Options {
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile$2;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginV2Options {
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginWithIdpConnectionIdentifiers {
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
}
interface LoginWithIdpConnectionOptions {
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
interface LoginWithIdpConnectionCallbackOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$1[];
    queryParams?: QueryParametersEntry$1[];
    headers?: HeadersEntry$1[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface LoginCallbackOptions {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsOptions {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnOptions {
    /** profile of the identity */
    profile?: IdentityProfile$2;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface LogoutOptions {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}

declare function registerV2$1(httpClient: HttpClient): RegisterV2Signature;
interface RegisterV2Signature {
    /**
     * Registers a new member.
     *
     * Typically, after a sucessful registration, you generate and use member tokens for the
     * registered member so that subsequent API calls are called as part of a member session.
     *
     * If the email used to register the member already exists as a contact email, the registering
     * member need to verify the email address using a code that is sent to the address.
     * @param - Identifier of registering member.
     */
    (loginId: LoginId, options?: RegisterV2Options | undefined): Promise<StateMachineResponse$2 & StateMachineResponseNonNullableFields$2>;
}
declare function loginV2$1(httpClient: HttpClient): LoginV2Signature;
interface LoginV2Signature {
    /**
     * Logs in an existing user.
     *
     * Typically, after a sucessful login, you generate and use member tokens for the
     * logged-in member so that subsequent API calls are called as part of a member session.
     * @param - Identifier of identity logging in.
     */
    (loginId: LoginId, options?: LoginV2Options | undefined): Promise<StateMachineResponse$2 & StateMachineResponseNonNullableFields$2>;
}
declare function changePassword$1(httpClient: HttpClient): ChangePasswordSignature;
interface ChangePasswordSignature {
    /**
     * Changes the password of a logged in user.
     * @param - The new password to set for the logged in user
     */
    (newPassword: string): Promise<void>;
}
declare function loginWithIdpConnection$1(httpClient: HttpClient): LoginWithIdpConnectionSignature;
interface LoginWithIdpConnectionSignature {
    /** @param - The type of the tenant the caller wants to login into */
    (identifiers: LoginWithIdpConnectionIdentifiers, tenantType: TenantType$1, options?: LoginWithIdpConnectionOptions | undefined): Promise<RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
}
declare function loginWithIdpConnectionCallback$1(httpClient: HttpClient): LoginWithIdpConnectionCallbackSignature;
interface LoginWithIdpConnectionCallbackSignature {
    /**
     * REQUIRES path params `tenant_type`, `tenant_id` and `idp_connection_id`
     */
    (options?: LoginWithIdpConnectionCallbackOptions | undefined): Promise<RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
}
declare function loginCallback$1(httpClient: HttpClient): LoginCallbackSignature;
interface LoginCallbackSignature {
    /** */
    (options?: LoginCallbackOptions | undefined): Promise<RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
}
declare function loginWithIdpConnectionTokenParams$1(httpClient: HttpClient): LoginWithIdpConnectionTokenParamsSignature;
interface LoginWithIdpConnectionTokenParamsSignature {
    /** */
    (options?: LoginWithIdpConnectionTokenParamsOptions | undefined): Promise<StateMachineResponse$2 & StateMachineResponseNonNullableFields$2>;
}
declare function signOn$1(httpClient: HttpClient): SignOnSignature;
interface SignOnSignature {
    /** @param - the identifier of the identity */
    (loginId: LoginId, options?: SignOnOptions | undefined): Promise<SignOnResponse & SignOnResponseNonNullableFields>;
}
declare function logout$1(httpClient: HttpClient): LogoutSignature;
interface LogoutSignature {
    /**
     * Logs out a member.
     */
    (options?: LogoutOptions | undefined): Promise<RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
}

declare const registerV2: MaybeContext<BuildRESTFunction<typeof registerV2$1> & typeof registerV2$1>;
declare const loginV2: MaybeContext<BuildRESTFunction<typeof loginV2$1> & typeof loginV2$1>;
declare const changePassword: MaybeContext<BuildRESTFunction<typeof changePassword$1> & typeof changePassword$1>;
declare const loginWithIdpConnection: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnection$1> & typeof loginWithIdpConnection$1>;
declare const loginWithIdpConnectionCallback: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnectionCallback$1> & typeof loginWithIdpConnectionCallback$1>;
declare const loginCallback: MaybeContext<BuildRESTFunction<typeof loginCallback$1> & typeof loginCallback$1>;
declare const loginWithIdpConnectionTokenParams: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnectionTokenParams$1> & typeof loginWithIdpConnectionTokenParams$1>;
declare const signOn: MaybeContext<BuildRESTFunction<typeof signOn$1> & typeof signOn$1>;
declare const logout: MaybeContext<BuildRESTFunction<typeof logout$1> & typeof logout$1>;

type index_d$6_Authentication = Authentication;
type index_d$6_CaptchaToken = CaptchaToken;
type index_d$6_CaptchaTokenTokenOneOf = CaptchaTokenTokenOneOf;
type index_d$6_ChangePasswordRequest = ChangePasswordRequest;
type index_d$6_ChangePasswordResponse = ChangePasswordResponse;
type index_d$6_LoginCallbackOptions = LoginCallbackOptions;
type index_d$6_LoginCallbackRequest = LoginCallbackRequest;
type index_d$6_LoginId = LoginId;
type index_d$6_LoginIdTypeOneOf = LoginIdTypeOneOf;
type index_d$6_LoginV2Options = LoginV2Options;
type index_d$6_LoginV2Request = LoginV2Request;
type index_d$6_LoginWithIdpConnectionCallbackOptions = LoginWithIdpConnectionCallbackOptions;
type index_d$6_LoginWithIdpConnectionIdentifiers = LoginWithIdpConnectionIdentifiers;
type index_d$6_LoginWithIdpConnectionOptions = LoginWithIdpConnectionOptions;
type index_d$6_LoginWithIdpConnectionRequest = LoginWithIdpConnectionRequest;
type index_d$6_LoginWithIdpConnectionTokenParamsOptions = LoginWithIdpConnectionTokenParamsOptions;
type index_d$6_LoginWithIdpConnectionTokenParamsRequest = LoginWithIdpConnectionTokenParamsRequest;
type index_d$6_LogoutOptions = LogoutOptions;
type index_d$6_LogoutRequest = LogoutRequest;
type index_d$6_RegisterV2Options = RegisterV2Options;
type index_d$6_RegisterV2Request = RegisterV2Request;
type index_d$6_SignOnOptions = SignOnOptions;
type index_d$6_SignOnRequest = SignOnRequest;
type index_d$6_SignOnResponse = SignOnResponse;
type index_d$6_SignOnResponseNonNullableFields = SignOnResponseNonNullableFields;
declare const index_d$6_changePassword: typeof changePassword;
declare const index_d$6_loginCallback: typeof loginCallback;
declare const index_d$6_loginV2: typeof loginV2;
declare const index_d$6_loginWithIdpConnection: typeof loginWithIdpConnection;
declare const index_d$6_loginWithIdpConnectionCallback: typeof loginWithIdpConnectionCallback;
declare const index_d$6_loginWithIdpConnectionTokenParams: typeof loginWithIdpConnectionTokenParams;
declare const index_d$6_logout: typeof logout;
declare const index_d$6_registerV2: typeof registerV2;
declare const index_d$6_signOn: typeof signOn;
declare namespace index_d$6 {
  export { type Address$2 as Address, AddressTag$2 as AddressTag, type AddressWrapper$2 as AddressWrapper, type index_d$6_Authentication as Authentication, type AuthenticatorConnection$2 as AuthenticatorConnection, type index_d$6_CaptchaToken as CaptchaToken, type index_d$6_CaptchaTokenTokenOneOf as CaptchaTokenTokenOneOf, type index_d$6_ChangePasswordRequest as ChangePasswordRequest, type index_d$6_ChangePasswordResponse as ChangePasswordResponse, type Connection$2 as Connection, type ConnectionTypeOneOf$2 as ConnectionTypeOneOf, type CustomField$2 as CustomField, type CustomValue$2 as CustomValue, type CustomValueValueOneOf$2 as CustomValueValueOneOf, type Email$2 as Email, EmailTag$2 as EmailTag, type Factor$2 as Factor, FactorType$2 as FactorType, type HeadersEntry$1 as HeadersEntry, type Identifier$2 as Identifier, type IdentifierValueOneOf$2 as IdentifierValueOneOf, type Identity$2 as Identity, type IdentityProfile$2 as IdentityProfile, type IdpConnection$2 as IdpConnection, type ListValue$2 as ListValue, type index_d$6_LoginCallbackOptions as LoginCallbackOptions, type index_d$6_LoginCallbackRequest as LoginCallbackRequest, type index_d$6_LoginId as LoginId, type index_d$6_LoginIdTypeOneOf as LoginIdTypeOneOf, type index_d$6_LoginV2Options as LoginV2Options, type index_d$6_LoginV2Request as LoginV2Request, type index_d$6_LoginWithIdpConnectionCallbackOptions as LoginWithIdpConnectionCallbackOptions, type index_d$6_LoginWithIdpConnectionIdentifiers as LoginWithIdpConnectionIdentifiers, type index_d$6_LoginWithIdpConnectionOptions as LoginWithIdpConnectionOptions, type index_d$6_LoginWithIdpConnectionRequest as LoginWithIdpConnectionRequest, type index_d$6_LoginWithIdpConnectionTokenParamsOptions as LoginWithIdpConnectionTokenParamsOptions, type index_d$6_LoginWithIdpConnectionTokenParamsRequest as LoginWithIdpConnectionTokenParamsRequest, type index_d$6_LogoutOptions as LogoutOptions, type index_d$6_LogoutRequest as LogoutRequest, type MapValue$2 as MapValue, type Metadata$2 as Metadata, type PathParametersEntry$1 as PathParametersEntry, type Phone$2 as Phone, PhoneTag$2 as PhoneTag, PrivacyStatus$2 as PrivacyStatus, type QueryParametersEntry$1 as QueryParametersEntry, type RawHttpRequest$1 as RawHttpRequest, type RawHttpResponse$1 as RawHttpResponse, type RawHttpResponseNonNullableFields$1 as RawHttpResponseNonNullableFields, Reason$2 as Reason, type index_d$6_RegisterV2Options as RegisterV2Options, type index_d$6_RegisterV2Request as RegisterV2Request, type SecondaryEmail$2 as SecondaryEmail, type index_d$6_SignOnOptions as SignOnOptions, type index_d$6_SignOnRequest as SignOnRequest, type index_d$6_SignOnResponse as SignOnResponse, type index_d$6_SignOnResponseNonNullableFields as SignOnResponseNonNullableFields, type StateMachineResponse$2 as StateMachineResponse, type StateMachineResponseNonNullableFields$2 as StateMachineResponseNonNullableFields, StateType$2 as StateType, Status$2 as Status, StatusName$2 as StatusName, type StatusV2$2 as StatusV2, TenantType$1 as TenantType, type V1CustomValue$2 as V1CustomValue, type V1CustomValueValueOneOf$2 as V1CustomValueValueOneOf, type V1ListValue$2 as V1ListValue, type V1MapValue$2 as V1MapValue, index_d$6_changePassword as changePassword, index_d$6_loginCallback as loginCallback, index_d$6_loginV2 as loginV2, index_d$6_loginWithIdpConnection as loginWithIdpConnection, index_d$6_loginWithIdpConnectionCallback as loginWithIdpConnectionCallback, index_d$6_loginWithIdpConnectionTokenParams as loginWithIdpConnectionTokenParams, index_d$6_logout as logout, index_d$6_registerV2 as registerV2, index_d$6_signOn as signOn };
}

/** Recovery token proto is the saved data on the recovery token. */
interface RecoveryToken {
    /**
     * Recovery token ID
     * @readonly
     */
    _id?: string | null;
    /**
     * Represents the time this SessionToken was created
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * tenantId
     * @readonly
     */
    tenantId?: string;
    /**
     * TenantType
     * @readonly
     */
    tenantType?: TenantType;
    /**
     * identity id
     * @readonly
     */
    identityId?: string;
}
declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface SendRecoveryEmailRequest {
    /** Email address associated with the account to recover. */
    email: string;
    /** Language of the email to be sent. Defaults to the language specified in the member's profile. */
    language?: string | null;
    /** Where to redirect to after a successful recovery. */
    redirect?: Redirect;
}
interface Redirect {
    /** The URL to redirect to after a successful recovery. */
    url?: string;
    /** Caller identifier. */
    clientId?: string | null;
}
interface SendRecoveryEmailResponse {
}
interface SendActivationEmailRequest {
    /** Id of the activating user */
    identityId: string;
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
interface EmailOptions {
    /** language of the email - if not received will fallback to the identity language */
    language?: string | null;
    /** Where to redirect after a successful activation process */
    redirect?: Redirect;
}
interface SendActivationEmailResponse {
}
interface RecoverRequest {
    /** recovery token */
    recoveryToken: string;
    /** new password to set for the identity */
    password?: string | null;
}
interface StateMachineResponse$1 {
    /** The current state of the login or registration process. */
    state?: StateType$1;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$1;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$1>;
}
declare enum StateType$1 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$1 {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$1[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$1[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$1;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$1;
    /** Identity email address. */
    email?: Email$1;
    /** Identity's current status. */
    status?: StatusV2$1;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$1[];
}
interface Identifier$1 extends IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
interface Connection$1 extends ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
/** @oneof */
interface ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
interface IdpConnection$1 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$1 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile$1 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$1;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$1[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$1[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$1[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$1[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$1 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$1 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$1;
}
interface V1CustomValue$1 extends V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
/** @oneof */
interface V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
interface V1ListValue$1 {
    /** Custom value. */
    value?: V1CustomValue$1[];
}
interface V1MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$1>;
}
interface SecondaryEmail$1 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$1;
}
declare enum EmailTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$1 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$1;
}
declare enum PhoneTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$1 {
    /** Address. */
    address?: Address$1;
    /** Address tag. */
    tag?: AddressTag$1;
}
/** Physical address */
interface Address$1 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$1 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata$1 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$1 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$1 {
    name?: StatusName$1;
    reasons?: Reason$1[];
}
declare enum StatusName$1 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$1 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$1 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$1;
    /** Factor status. */
    status?: Status$1;
}
declare enum FactorType$1 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$1 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$1 extends CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
/** @oneof */
interface CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
interface ListValue$1 {
    /** Custom value. */
    value?: CustomValue$1[];
}
interface MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$1>;
}
interface IdentifierNonNullableFields$1 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$1 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$1 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$1 {
    idpConnection?: IdpConnectionNonNullableFields$1;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$1;
}
interface V1ListValueNonNullableFields$1 {
    value: V1CustomValueNonNullableFields$1[];
}
interface V1CustomValueNonNullableFields$1 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$1;
}
interface CustomFieldNonNullableFields$1 {
    name: string;
    value?: V1CustomValueNonNullableFields$1;
}
interface SecondaryEmailNonNullableFields$1 {
    email: string;
    tag: EmailTag$1;
}
interface PhoneNonNullableFields$1 {
    phone: string;
    tag: PhoneTag$1;
}
interface AddressWrapperNonNullableFields$1 {
    tag: AddressTag$1;
}
interface IdentityProfileNonNullableFields$1 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$1;
    customFields: CustomFieldNonNullableFields$1[];
    secondaryEmails: SecondaryEmailNonNullableFields$1[];
    phonesV2: PhoneNonNullableFields$1[];
    addresses: AddressWrapperNonNullableFields$1[];
}
interface MetadataNonNullableFields$1 {
    tags: string[];
}
interface EmailNonNullableFields$1 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$1 {
    name: StatusName$1;
    reasons: Reason$1[];
}
interface FactorNonNullableFields$1 {
    factorId: string;
    type: FactorType$1;
    status: Status$1;
}
interface IdentityNonNullableFields$1 {
    identifiers: IdentifierNonNullableFields$1[];
    connections: ConnectionNonNullableFields$1[];
    identityProfile?: IdentityProfileNonNullableFields$1;
    metadata?: MetadataNonNullableFields$1;
    email?: EmailNonNullableFields$1;
    status?: StatusV2NonNullableFields$1;
    factors: FactorNonNullableFields$1[];
}
interface StateMachineResponseNonNullableFields$1 {
    state: StateType$1;
    identity?: IdentityNonNullableFields$1;
}
interface SendRecoveryEmailOptions {
    /** Language of the email to be sent. Defaults to the language specified in the member's profile. */
    language?: string | null;
    /** Where to redirect to after a successful recovery. */
    redirect?: Redirect;
}
interface SendActivationEmailOptions {
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
interface RecoverOptions {
    /** new password to set for the identity */
    password?: string | null;
}

declare function sendRecoveryEmail$1(httpClient: HttpClient): SendRecoveryEmailSignature;
interface SendRecoveryEmailSignature {
    /**
     * Sends a member an email containing a customized link to a Wix-managed page
     * where the member can set a new password for their account.
     * @param - Email address associated with the account to recover.
     */
    (email: string, options?: SendRecoveryEmailOptions | undefined): Promise<void>;
}
declare function sendActivationEmail$1(httpClient: HttpClient): SendActivationEmailSignature;
interface SendActivationEmailSignature {
    /**
     * Sends an activation email with an activation token
     * making the transition from initial contact to a site member
     * @param - Id of the activating user
     */
    (identityId: string, options?: SendActivationEmailOptions | undefined): Promise<void>;
}
declare function recover$1(httpClient: HttpClient): RecoverSignature;
interface RecoverSignature {
    /** @param - recovery token */
    (recoveryToken: string, options?: RecoverOptions | undefined): Promise<StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;
}

declare const sendRecoveryEmail: MaybeContext<BuildRESTFunction<typeof sendRecoveryEmail$1> & typeof sendRecoveryEmail$1>;
declare const sendActivationEmail: MaybeContext<BuildRESTFunction<typeof sendActivationEmail$1> & typeof sendActivationEmail$1>;
declare const recover: MaybeContext<BuildRESTFunction<typeof recover$1> & typeof recover$1>;

type index_d$5_EmailOptions = EmailOptions;
type index_d$5_RecoverOptions = RecoverOptions;
type index_d$5_RecoverRequest = RecoverRequest;
type index_d$5_RecoveryToken = RecoveryToken;
type index_d$5_Redirect = Redirect;
type index_d$5_SendActivationEmailOptions = SendActivationEmailOptions;
type index_d$5_SendActivationEmailRequest = SendActivationEmailRequest;
type index_d$5_SendActivationEmailResponse = SendActivationEmailResponse;
type index_d$5_SendRecoveryEmailOptions = SendRecoveryEmailOptions;
type index_d$5_SendRecoveryEmailRequest = SendRecoveryEmailRequest;
type index_d$5_SendRecoveryEmailResponse = SendRecoveryEmailResponse;
type index_d$5_TenantType = TenantType;
declare const index_d$5_TenantType: typeof TenantType;
declare const index_d$5_recover: typeof recover;
declare const index_d$5_sendActivationEmail: typeof sendActivationEmail;
declare const index_d$5_sendRecoveryEmail: typeof sendRecoveryEmail;
declare namespace index_d$5 {
  export { type Address$1 as Address, AddressTag$1 as AddressTag, type AddressWrapper$1 as AddressWrapper, type AuthenticatorConnection$1 as AuthenticatorConnection, type Connection$1 as Connection, type ConnectionTypeOneOf$1 as ConnectionTypeOneOf, type CustomField$1 as CustomField, type CustomValue$1 as CustomValue, type CustomValueValueOneOf$1 as CustomValueValueOneOf, type Email$1 as Email, type index_d$5_EmailOptions as EmailOptions, EmailTag$1 as EmailTag, type Factor$1 as Factor, FactorType$1 as FactorType, type Identifier$1 as Identifier, type IdentifierValueOneOf$1 as IdentifierValueOneOf, type Identity$1 as Identity, type IdentityProfile$1 as IdentityProfile, type IdpConnection$1 as IdpConnection, type ListValue$1 as ListValue, type MapValue$1 as MapValue, type Metadata$1 as Metadata, type Phone$1 as Phone, PhoneTag$1 as PhoneTag, PrivacyStatus$1 as PrivacyStatus, Reason$1 as Reason, type index_d$5_RecoverOptions as RecoverOptions, type index_d$5_RecoverRequest as RecoverRequest, type index_d$5_RecoveryToken as RecoveryToken, type index_d$5_Redirect as Redirect, type SecondaryEmail$1 as SecondaryEmail, type index_d$5_SendActivationEmailOptions as SendActivationEmailOptions, type index_d$5_SendActivationEmailRequest as SendActivationEmailRequest, type index_d$5_SendActivationEmailResponse as SendActivationEmailResponse, type index_d$5_SendRecoveryEmailOptions as SendRecoveryEmailOptions, type index_d$5_SendRecoveryEmailRequest as SendRecoveryEmailRequest, type index_d$5_SendRecoveryEmailResponse as SendRecoveryEmailResponse, type StateMachineResponse$1 as StateMachineResponse, type StateMachineResponseNonNullableFields$1 as StateMachineResponseNonNullableFields, StateType$1 as StateType, Status$1 as Status, StatusName$1 as StatusName, type StatusV2$1 as StatusV2, index_d$5_TenantType as TenantType, type V1CustomValue$1 as V1CustomValue, type V1CustomValueValueOneOf$1 as V1CustomValueValueOneOf, type V1ListValue$1 as V1ListValue, type V1MapValue$1 as V1MapValue, index_d$5_recover as recover, index_d$5_sendActivationEmail as sendActivationEmail, index_d$5_sendRecoveryEmail as sendRecoveryEmail };
}

interface StartResponse {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target;
}
declare enum Target {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
interface VerifyRequest {
    /** the code to verify */
    code?: string;
    /** the identifier of the verification process */
    verificationId?: string;
}
interface VerifyResponse {
}
interface VerifyDuringAuthenticationRequest {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse {
    /** The current state of the login or registration process. */
    state?: StateType;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue>;
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor[];
}
interface Identifier extends IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
declare enum FactorType {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface ResendDuringAuthenticationRequest {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StartResponseNonNullableFields {
    verificationId: string;
}
interface IdentifierNonNullableFields {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    identifiers: IdentifierNonNullableFields[];
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
interface StateMachineResponseNonNullableFields {
    state: StateType;
    identity?: IdentityNonNullableFields;
}
interface StartOptions {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target;
}
interface VerifyDuringAuthenticationOptions {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}

declare function start$1(httpClient: HttpClient): StartSignature;
interface StartSignature {
    /**
     * starts a verification process
     * example: sends a code to the identity's email
     */
    (options?: StartOptions | undefined): Promise<StartResponse & StartResponseNonNullableFields>;
}
declare function verifyDuringAuthentication$1(httpClient: HttpClient): VerifyDuringAuthenticationSignature;
interface VerifyDuringAuthenticationSignature {
    /**
     * Continues the registration process when a member is required to verify an email address
     * using a verification code received by email.
     *
     * Email verification is required when the registering member is already listed as a contact.
     *
     * Typically, after a successful verification, you generate and use member tokens for the
     * registered member so that subsequent API calls are called as part of a member session.
     * @param - The code to verify.
     */
    (code: string, options: VerifyDuringAuthenticationOptions): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
}
declare function resendDuringAuthentication$1(httpClient: HttpClient): ResendDuringAuthenticationSignature;
interface ResendDuringAuthenticationSignature {
    /**
     * Resend the verification email and continue the registration process when a member is required to verify an email address
     * using a verification code received by email.
     * @param - A state token representing the `REQUIRE_EMAIL_VERIFICATION` state.
     */
    (stateToken: string): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
}

declare const start: MaybeContext<BuildRESTFunction<typeof start$1> & typeof start$1>;
declare const verifyDuringAuthentication: MaybeContext<BuildRESTFunction<typeof verifyDuringAuthentication$1> & typeof verifyDuringAuthentication$1>;
declare const resendDuringAuthentication: MaybeContext<BuildRESTFunction<typeof resendDuringAuthentication$1> & typeof resendDuringAuthentication$1>;

type index_d$4_Address = Address;
type index_d$4_AddressTag = AddressTag;
declare const index_d$4_AddressTag: typeof AddressTag;
type index_d$4_AddressWrapper = AddressWrapper;
type index_d$4_AuthenticatorConnection = AuthenticatorConnection;
type index_d$4_Connection = Connection;
type index_d$4_ConnectionTypeOneOf = ConnectionTypeOneOf;
type index_d$4_CustomField = CustomField;
type index_d$4_CustomValue = CustomValue;
type index_d$4_CustomValueValueOneOf = CustomValueValueOneOf;
type index_d$4_Email = Email;
type index_d$4_EmailTag = EmailTag;
declare const index_d$4_EmailTag: typeof EmailTag;
type index_d$4_Factor = Factor;
type index_d$4_FactorType = FactorType;
declare const index_d$4_FactorType: typeof FactorType;
type index_d$4_Identifier = Identifier;
type index_d$4_IdentifierValueOneOf = IdentifierValueOneOf;
type index_d$4_Identity = Identity;
type index_d$4_IdentityProfile = IdentityProfile;
type index_d$4_IdpConnection = IdpConnection;
type index_d$4_ListValue = ListValue;
type index_d$4_MapValue = MapValue;
type index_d$4_Metadata = Metadata;
type index_d$4_Phone = Phone;
type index_d$4_PhoneTag = PhoneTag;
declare const index_d$4_PhoneTag: typeof PhoneTag;
type index_d$4_PrivacyStatus = PrivacyStatus;
declare const index_d$4_PrivacyStatus: typeof PrivacyStatus;
type index_d$4_Reason = Reason;
declare const index_d$4_Reason: typeof Reason;
type index_d$4_ResendDuringAuthenticationRequest = ResendDuringAuthenticationRequest;
type index_d$4_SecondaryEmail = SecondaryEmail;
type index_d$4_StartOptions = StartOptions;
type index_d$4_StartRequest = StartRequest;
type index_d$4_StartResponse = StartResponse;
type index_d$4_StartResponseNonNullableFields = StartResponseNonNullableFields;
type index_d$4_StateMachineResponse = StateMachineResponse;
type index_d$4_StateMachineResponseNonNullableFields = StateMachineResponseNonNullableFields;
type index_d$4_StateType = StateType;
declare const index_d$4_StateType: typeof StateType;
type index_d$4_Status = Status;
declare const index_d$4_Status: typeof Status;
type index_d$4_StatusName = StatusName;
declare const index_d$4_StatusName: typeof StatusName;
type index_d$4_StatusV2 = StatusV2;
type index_d$4_Target = Target;
declare const index_d$4_Target: typeof Target;
type index_d$4_V1CustomValue = V1CustomValue;
type index_d$4_V1CustomValueValueOneOf = V1CustomValueValueOneOf;
type index_d$4_V1ListValue = V1ListValue;
type index_d$4_V1MapValue = V1MapValue;
type index_d$4_VerifyDuringAuthenticationOptions = VerifyDuringAuthenticationOptions;
type index_d$4_VerifyDuringAuthenticationRequest = VerifyDuringAuthenticationRequest;
type index_d$4_VerifyRequest = VerifyRequest;
type index_d$4_VerifyResponse = VerifyResponse;
declare const index_d$4_resendDuringAuthentication: typeof resendDuringAuthentication;
declare const index_d$4_start: typeof start;
declare const index_d$4_verifyDuringAuthentication: typeof verifyDuringAuthentication;
declare namespace index_d$4 {
  export { type index_d$4_Address as Address, index_d$4_AddressTag as AddressTag, type index_d$4_AddressWrapper as AddressWrapper, type index_d$4_AuthenticatorConnection as AuthenticatorConnection, type index_d$4_Connection as Connection, type index_d$4_ConnectionTypeOneOf as ConnectionTypeOneOf, type index_d$4_CustomField as CustomField, type index_d$4_CustomValue as CustomValue, type index_d$4_CustomValueValueOneOf as CustomValueValueOneOf, type index_d$4_Email as Email, index_d$4_EmailTag as EmailTag, type index_d$4_Factor as Factor, index_d$4_FactorType as FactorType, type index_d$4_Identifier as Identifier, type index_d$4_IdentifierValueOneOf as IdentifierValueOneOf, type index_d$4_Identity as Identity, type index_d$4_IdentityProfile as IdentityProfile, type index_d$4_IdpConnection as IdpConnection, type index_d$4_ListValue as ListValue, type index_d$4_MapValue as MapValue, type index_d$4_Metadata as Metadata, type index_d$4_Phone as Phone, index_d$4_PhoneTag as PhoneTag, index_d$4_PrivacyStatus as PrivacyStatus, index_d$4_Reason as Reason, type index_d$4_ResendDuringAuthenticationRequest as ResendDuringAuthenticationRequest, type index_d$4_SecondaryEmail as SecondaryEmail, type index_d$4_StartOptions as StartOptions, type index_d$4_StartRequest as StartRequest, type index_d$4_StartResponse as StartResponse, type index_d$4_StartResponseNonNullableFields as StartResponseNonNullableFields, type index_d$4_StateMachineResponse as StateMachineResponse, type index_d$4_StateMachineResponseNonNullableFields as StateMachineResponseNonNullableFields, index_d$4_StateType as StateType, index_d$4_Status as Status, index_d$4_StatusName as StatusName, type index_d$4_StatusV2 as StatusV2, index_d$4_Target as Target, type index_d$4_V1CustomValue as V1CustomValue, type index_d$4_V1CustomValueValueOneOf as V1CustomValueValueOneOf, type index_d$4_V1ListValue as V1ListValue, type index_d$4_V1MapValue as V1MapValue, type index_d$4_VerifyDuringAuthenticationOptions as VerifyDuringAuthenticationOptions, type index_d$4_VerifyDuringAuthenticationRequest as VerifyDuringAuthenticationRequest, type index_d$4_VerifyRequest as VerifyRequest, type index_d$4_VerifyResponse as VerifyResponse, index_d$4_resendDuringAuthentication as resendDuringAuthentication, index_d$4_start as start, index_d$4_verifyDuringAuthentication as verifyDuringAuthentication };
}

interface AccountInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Account ID.
     * @readonly
     */
    accountId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /**
     * Deprecated. Use `policyIds`.
     * @deprecated
     */
    role?: string;
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user has declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus$2;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /** Date the invite was last updated. */
    dateUpdated?: Date | null;
    /** Assets the users are invited to join. */
    assignments?: InviteResourceAssignment[];
    /** Invite expiration date. */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus$2 {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface InviteResourceAssignment {
    /** Role ID. */
    policyId?: string;
    /** Resources the user will be able to access. */
    assignments?: InviteAssignment[];
}
interface InviteAssignment {
    /** Full name of resource to be assigned. */
    fullNameResource?: FullNameResource;
}
interface FullNameResource extends FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** @oneof */
interface FullNameResourceResourceContextOneOf {
    /** Specific site details. */
    siteContext?: SiteResourceContext;
    /** Specific account details. */
    accountContext?: AccountResourceContext;
}
/** Site resource context. It indicates that the resource is under a site (can be the site itself or some asset of a site, like a blog post) */
interface SiteResourceContext {
    /** Site ID. */
    metasiteId?: string;
}
/** Account resource contexts. It indicates that the resource is under the account (can be the account itself or some asset of an account, like a logo or a domain) */
interface AccountResourceContext {
    /** Account ID. */
    accountId?: string;
}
interface OrganizationResourceContext {
}
/**
 * A custom resource. Is used to represent some asset that is not a direct resource context (site or account), but something custom.
 * For example: payment method, blog post, domain, logo.
 */
interface Resource$1 {
    /** The resource id. */
    _id?: string | null;
    /** The resource type */
    type?: string | null;
}
interface PolicyCondition {
    /** The type of the condition */
    condition?: ConditionType;
}
interface ConditionType extends ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition$1;
}
/** @oneof */
interface ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition$1;
}
interface SimpleCondition {
    attrName?: string;
    value?: SimpleConditionValue;
    op?: SimpleConditionOperator;
    conditionModelId?: string;
}
interface SimpleConditionValue extends SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
/** @oneof */
interface SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
declare enum SimpleConditionOperator {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
interface JoinedCondition {
    /** The operator that should be used when evaluating the condition */
    op?: JoinedConditionOperator;
    /** The conditions that should be evaluated, and then joined using the operator provided */
    conditions?: ConditionType[];
}
declare enum JoinedConditionOperator {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
interface EnvironmentCondition extends EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
/** @oneof */
interface EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
interface ExperimentCondition {
    spec?: string;
    fallbackValue?: string;
    expectedValue?: string;
}
interface Condition$1 {
    /** The unique identifier of the condition model. Indicates which actions the condition is working on */
    conditionModelId?: string;
    /** The operator that should be evaluated */
    operator?: ConditionOperator;
}
interface ConditionOperator extends ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
/** @oneof */
interface ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
interface EqualOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the other side (attribute/value) */
    attrName?: string;
    /** The value to compare to. If the two parties are equal - we will return true. */
    value?: ConditionValue;
}
interface ConditionValue extends ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
/** @oneof */
interface ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
interface LikeOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the regex values provided. */
    attrName?: string;
    /** The regex values which the attribute value should be evaluated on. If the attribute value matches at least one of the regular expressions provided - we will return true */
    values?: string[];
}
interface ExperimentOperator {
    /** The spec to conduct the experiment on. */
    spec?: string;
    /** The value to use if the experiment could not be conducted */
    fallbackValue?: string;
    /** The expected value of the experiment conduction. If it matches the actual value - true will be returned. Otherwise - false. */
    expectedValue?: string;
}
/** Implies that the policy takes affect only if the depend on subject is permitted as well. */
interface DependOnOperator {
    /** The subject on which the current entry depends on. If the subject is allowed to perform what the query was about - the condition will be evaluated to true. Otherwise - false */
    dependOnSubject?: Subject$1;
}
interface Subject$1 {
    /** ID of identity assigned to the asset. */
    _id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectType$2;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext$1;
}
declare enum SubjectType$2 {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
interface SubjectContext$1 {
    _id?: string;
    contextType?: SubjectContextType$1;
}
declare enum SubjectContextType$1 {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface GetAccountInvitesRequest {
}
interface GetAccountInvitesResponse {
    invites?: AccountInvite[];
}
interface GetAccountInviteRequest {
    _id?: string;
}
interface GetAccountInviteResponse {
    invite?: AccountInvite;
}
interface AccountInviteRequest {
    role?: string;
    email?: string;
    policyIds?: string[];
}
interface AccountInviteResponse {
    invite?: AccountInvite;
}
interface CreateInviteRequest {
    /** Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite). */
    subjectsAssignments: SubjectInviteAssignments[];
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface SubjectInviteAssignments {
    /** Invitee's email address. */
    subjectEmail?: string;
    /** Mapping of roles (referred to here as policies) and assets (referred to here as resources) that will be assigned to the invitee when they accept the invite. When no resources are specified, the invitee will be given access to everything within the account. */
    assignments?: InviteResourceAssignment[];
}
interface CreateInviteResponse {
    /** Invites that were sent successfully. */
    successfulInvites?: AccountInvite[];
    /** Invites that failed. */
    failedInvites?: InviteFailure[];
}
interface InviteFailure {
    /** Email address of the failed invite. */
    subjectEmail?: string;
    /** Error description. */
    errorMessage?: string;
}
interface BulkAccountInviteRequest {
    role?: string;
    emails?: string[];
    policyIds?: string[];
}
interface BulkAccountInviteResponse {
    invites?: AccountInvite[];
    failedEmails?: string[];
}
interface ResendAccountInviteRequest {
    inviteId?: string;
    /** The language of emails that will be used only for recipients that don't have a user, in case this parameter is unspecified, the sender's language will be used instead */
    defaultEmailLanguage?: string | null;
}
interface AcceptAccountInviteRequest {
    inviteToken?: string;
}
interface AcceptAccountInviteResponse {
}
interface RevokeAccountInviteRequest {
    inviteId?: string;
}
interface RevokeAccountInviteResponse {
}
interface UpdateAccountInviteRequest {
    inviteId?: string;
    role?: string;
    policyIds?: string[];
}
interface UpdateAccountInviteResponse {
}
interface UpdateAccountInviteAssignmentsRequest {
    inviteId?: string;
    assignments?: InviteResourceAssignment[];
}
interface UpdateAccountInviteAssignmentsResponse {
}
interface ParseAccountInviteTokenRequest {
    inviteToken?: string;
}
interface ParseAccountInviteTokenResponse {
    inviteId?: string;
    accountId?: string;
    status?: InviteStatus$2;
}
interface SiteResourceContextNonNullableFields {
    metasiteId: string;
}
interface AccountResourceContextNonNullableFields {
    accountId: string;
}
interface FullNameResourceNonNullableFields {
    siteContext?: SiteResourceContextNonNullableFields;
    accountContext?: AccountResourceContextNonNullableFields;
}
interface SimpleConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface SimpleConditionNonNullableFields {
    attrName: string;
    value?: SimpleConditionValueNonNullableFields;
    op: SimpleConditionOperator;
    conditionModelId: string;
}
interface JoinedConditionNonNullableFields {
    op: JoinedConditionOperator;
    conditions: ConditionTypeNonNullableFields[];
}
interface ExperimentConditionNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface EnvironmentConditionNonNullableFields {
    experimentCondition?: ExperimentConditionNonNullableFields;
}
interface ConditionValueNonNullableFields {
    attrName: string;
    stringValue: string;
    boolValue: boolean;
}
interface EqualOperatorNonNullableFields {
    attrName: string;
    value?: ConditionValueNonNullableFields;
}
interface LikeOperatorNonNullableFields {
    attrName: string;
    values: string[];
}
interface ExperimentOperatorNonNullableFields {
    spec: string;
    fallbackValue: string;
    expectedValue: string;
}
interface SubjectContextNonNullableFields {
    _id: string;
    contextType: SubjectContextType$1;
}
interface SubjectNonNullableFields {
    _id: string;
    subjectType: SubjectType$2;
    context?: SubjectContextNonNullableFields;
}
interface DependOnOperatorNonNullableFields {
    dependOnSubject?: SubjectNonNullableFields;
}
interface ConditionOperatorNonNullableFields {
    equals?: EqualOperatorNonNullableFields;
    like?: LikeOperatorNonNullableFields;
    experiment?: ExperimentOperatorNonNullableFields;
    dependOn?: DependOnOperatorNonNullableFields;
}
interface ConditionNonNullableFields {
    conditionModelId: string;
    operator?: ConditionOperatorNonNullableFields;
}
interface ConditionTypeNonNullableFields {
    simpleCondition?: SimpleConditionNonNullableFields;
    joinedConditions?: JoinedConditionNonNullableFields;
    environmentCondition?: EnvironmentConditionNonNullableFields;
    condition?: ConditionNonNullableFields;
}
interface PolicyConditionNonNullableFields {
    condition?: ConditionTypeNonNullableFields;
}
interface InviteAssignmentNonNullableFields {
    fullNameResource?: FullNameResourceNonNullableFields;
    condition?: PolicyConditionNonNullableFields;
}
interface InviteResourceAssignmentNonNullableFields {
    policyId: string;
    assignments: InviteAssignmentNonNullableFields[];
}
interface AccountInviteNonNullableFields {
    _id: string;
    accountId: string;
    email: string;
    role: string;
    inviterId: string;
    status: InviteStatus$2;
    acceptLink: string;
    inviterAccountId: string;
    policyIds: string[];
    assignments: InviteResourceAssignmentNonNullableFields[];
}
interface InviteFailureNonNullableFields {
    subjectEmail: string;
    errorMessage: string;
}
interface CreateInviteResponseNonNullableFields {
    successfulInvites: AccountInviteNonNullableFields[];
    failedInvites: InviteFailureNonNullableFields[];
}
interface CreateInviteOptions {
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}

declare function createInvite$1(httpClient: HttpClient): CreateInviteSignature;
interface CreateInviteSignature {
    /**
     * Creates and sends invite emails to a list of potential team members, inviting them to become team members of the requesting account.
     * The invites may be limited to a specific resource (site or other asset).
     * Maximum 50 invitees can be specified per call.
     *
     * > **Important**: This call requires an account level API key and cannot be authenticated with the standard authorization header. API keys are currently available to selected beta users only.
     * @param - Array of potential team members' email addresses and their corresponding assignments (how they will be assigned when they accept the invite).
     */
    (subjectsAssignments: SubjectInviteAssignments[], options?: CreateInviteOptions | undefined): Promise<CreateInviteResponse & CreateInviteResponseNonNullableFields>;
}

declare const createInvite: MaybeContext<BuildRESTFunction<typeof createInvite$1> & typeof createInvite$1>;

type index_d$3_AcceptAccountInviteRequest = AcceptAccountInviteRequest;
type index_d$3_AcceptAccountInviteResponse = AcceptAccountInviteResponse;
type index_d$3_AccountInvite = AccountInvite;
type index_d$3_AccountInviteRequest = AccountInviteRequest;
type index_d$3_AccountInviteResponse = AccountInviteResponse;
type index_d$3_AccountResourceContext = AccountResourceContext;
type index_d$3_BulkAccountInviteRequest = BulkAccountInviteRequest;
type index_d$3_BulkAccountInviteResponse = BulkAccountInviteResponse;
type index_d$3_ConditionOperator = ConditionOperator;
type index_d$3_ConditionOperatorOperatorsOneOf = ConditionOperatorOperatorsOneOf;
type index_d$3_ConditionType = ConditionType;
type index_d$3_ConditionTypeOfOneOf = ConditionTypeOfOneOf;
type index_d$3_ConditionValue = ConditionValue;
type index_d$3_ConditionValueValueOneOf = ConditionValueValueOneOf;
type index_d$3_CreateInviteOptions = CreateInviteOptions;
type index_d$3_CreateInviteRequest = CreateInviteRequest;
type index_d$3_CreateInviteResponse = CreateInviteResponse;
type index_d$3_CreateInviteResponseNonNullableFields = CreateInviteResponseNonNullableFields;
type index_d$3_DependOnOperator = DependOnOperator;
type index_d$3_EnvironmentCondition = EnvironmentCondition;
type index_d$3_EnvironmentConditionConditionOneOf = EnvironmentConditionConditionOneOf;
type index_d$3_EqualOperator = EqualOperator;
type index_d$3_ExperimentCondition = ExperimentCondition;
type index_d$3_ExperimentOperator = ExperimentOperator;
type index_d$3_FullNameResource = FullNameResource;
type index_d$3_FullNameResourceResourceContextOneOf = FullNameResourceResourceContextOneOf;
type index_d$3_GetAccountInviteRequest = GetAccountInviteRequest;
type index_d$3_GetAccountInviteResponse = GetAccountInviteResponse;
type index_d$3_GetAccountInvitesRequest = GetAccountInvitesRequest;
type index_d$3_GetAccountInvitesResponse = GetAccountInvitesResponse;
type index_d$3_InviteAssignment = InviteAssignment;
type index_d$3_InviteFailure = InviteFailure;
type index_d$3_InviteResourceAssignment = InviteResourceAssignment;
type index_d$3_JoinedCondition = JoinedCondition;
type index_d$3_JoinedConditionOperator = JoinedConditionOperator;
declare const index_d$3_JoinedConditionOperator: typeof JoinedConditionOperator;
type index_d$3_LikeOperator = LikeOperator;
type index_d$3_OrganizationResourceContext = OrganizationResourceContext;
type index_d$3_ParseAccountInviteTokenRequest = ParseAccountInviteTokenRequest;
type index_d$3_ParseAccountInviteTokenResponse = ParseAccountInviteTokenResponse;
type index_d$3_PolicyCondition = PolicyCondition;
type index_d$3_ResendAccountInviteRequest = ResendAccountInviteRequest;
type index_d$3_RevokeAccountInviteRequest = RevokeAccountInviteRequest;
type index_d$3_RevokeAccountInviteResponse = RevokeAccountInviteResponse;
type index_d$3_SimpleCondition = SimpleCondition;
type index_d$3_SimpleConditionOperator = SimpleConditionOperator;
declare const index_d$3_SimpleConditionOperator: typeof SimpleConditionOperator;
type index_d$3_SimpleConditionValue = SimpleConditionValue;
type index_d$3_SimpleConditionValueValueOneOf = SimpleConditionValueValueOneOf;
type index_d$3_SiteResourceContext = SiteResourceContext;
type index_d$3_SubjectInviteAssignments = SubjectInviteAssignments;
type index_d$3_UpdateAccountInviteAssignmentsRequest = UpdateAccountInviteAssignmentsRequest;
type index_d$3_UpdateAccountInviteAssignmentsResponse = UpdateAccountInviteAssignmentsResponse;
type index_d$3_UpdateAccountInviteRequest = UpdateAccountInviteRequest;
type index_d$3_UpdateAccountInviteResponse = UpdateAccountInviteResponse;
declare const index_d$3_createInvite: typeof createInvite;
declare namespace index_d$3 {
  export { type index_d$3_AcceptAccountInviteRequest as AcceptAccountInviteRequest, type index_d$3_AcceptAccountInviteResponse as AcceptAccountInviteResponse, type index_d$3_AccountInvite as AccountInvite, type index_d$3_AccountInviteRequest as AccountInviteRequest, type index_d$3_AccountInviteResponse as AccountInviteResponse, type index_d$3_AccountResourceContext as AccountResourceContext, type index_d$3_BulkAccountInviteRequest as BulkAccountInviteRequest, type index_d$3_BulkAccountInviteResponse as BulkAccountInviteResponse, type Condition$1 as Condition, type index_d$3_ConditionOperator as ConditionOperator, type index_d$3_ConditionOperatorOperatorsOneOf as ConditionOperatorOperatorsOneOf, type index_d$3_ConditionType as ConditionType, type index_d$3_ConditionTypeOfOneOf as ConditionTypeOfOneOf, type index_d$3_ConditionValue as ConditionValue, type index_d$3_ConditionValueValueOneOf as ConditionValueValueOneOf, type index_d$3_CreateInviteOptions as CreateInviteOptions, type index_d$3_CreateInviteRequest as CreateInviteRequest, type index_d$3_CreateInviteResponse as CreateInviteResponse, type index_d$3_CreateInviteResponseNonNullableFields as CreateInviteResponseNonNullableFields, type index_d$3_DependOnOperator as DependOnOperator, type index_d$3_EnvironmentCondition as EnvironmentCondition, type index_d$3_EnvironmentConditionConditionOneOf as EnvironmentConditionConditionOneOf, type index_d$3_EqualOperator as EqualOperator, type index_d$3_ExperimentCondition as ExperimentCondition, type index_d$3_ExperimentOperator as ExperimentOperator, type index_d$3_FullNameResource as FullNameResource, type index_d$3_FullNameResourceResourceContextOneOf as FullNameResourceResourceContextOneOf, type index_d$3_GetAccountInviteRequest as GetAccountInviteRequest, type index_d$3_GetAccountInviteResponse as GetAccountInviteResponse, type index_d$3_GetAccountInvitesRequest as GetAccountInvitesRequest, type index_d$3_GetAccountInvitesResponse as GetAccountInvitesResponse, type index_d$3_InviteAssignment as InviteAssignment, type index_d$3_InviteFailure as InviteFailure, type index_d$3_InviteResourceAssignment as InviteResourceAssignment, InviteStatus$2 as InviteStatus, type index_d$3_JoinedCondition as JoinedCondition, index_d$3_JoinedConditionOperator as JoinedConditionOperator, type index_d$3_LikeOperator as LikeOperator, type index_d$3_OrganizationResourceContext as OrganizationResourceContext, type index_d$3_ParseAccountInviteTokenRequest as ParseAccountInviteTokenRequest, type index_d$3_ParseAccountInviteTokenResponse as ParseAccountInviteTokenResponse, type index_d$3_PolicyCondition as PolicyCondition, type index_d$3_ResendAccountInviteRequest as ResendAccountInviteRequest, type Resource$1 as Resource, type index_d$3_RevokeAccountInviteRequest as RevokeAccountInviteRequest, type index_d$3_RevokeAccountInviteResponse as RevokeAccountInviteResponse, type index_d$3_SimpleCondition as SimpleCondition, index_d$3_SimpleConditionOperator as SimpleConditionOperator, type index_d$3_SimpleConditionValue as SimpleConditionValue, type index_d$3_SimpleConditionValueValueOneOf as SimpleConditionValueValueOneOf, type index_d$3_SiteResourceContext as SiteResourceContext, type Subject$1 as Subject, type SubjectContext$1 as SubjectContext, SubjectContextType$1 as SubjectContextType, type index_d$3_SubjectInviteAssignments as SubjectInviteAssignments, SubjectType$2 as SubjectType, type index_d$3_UpdateAccountInviteAssignmentsRequest as UpdateAccountInviteAssignmentsRequest, type index_d$3_UpdateAccountInviteAssignmentsResponse as UpdateAccountInviteAssignmentsResponse, type index_d$3_UpdateAccountInviteRequest as UpdateAccountInviteRequest, type index_d$3_UpdateAccountInviteResponse as UpdateAccountInviteResponse, index_d$3_createInvite as createInvite };
}

interface SiteInvite$1 {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Site ID the user is invited to as a collaborator.
     * @readonly
     */
    siteId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite Status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus$1;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** User's Wix Bookings staff ID, if relevant. */
    staffId?: string | null;
    /** Invite expiration date */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus$1 {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface GetSiteInvitesRequest {
}
interface GetSiteInvitesResponse {
    invites?: SiteInvite$1[];
}
interface QuerySiteInvitesRequest {
    /**
     * Supports only `filter` field with
     * `"filter" : {
     * "acceptedByAccountId":{"$in": [<id1>, <id2>, ...]}
     * }`
     */
    query?: QueryV2;
}
interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QuerySiteInvitesResponse {
    invites?: SiteInvite$1[];
}
interface GetSiteInviteRequest {
    _id?: string;
}
interface GetSiteInviteResponse {
    invite?: SiteInvite$1;
}
interface SiteInviteRequest {
    /** The role ids to be assigned */
    policyIds?: string[];
    /** Invitee email */
    email?: string;
    /** The language of emails that will be used only for recipients that don't have a user, in case this parameter is unspecified, the sender's language will be used instead */
    defaultEmailLanguage?: string | null;
}
interface SiteInviteResponse {
    /** Invites that were sent. */
    invite?: SiteInvite$1;
}
interface BulkSiteInviteRequest {
    /** Role IDs, referred to as policy IDs, to assign to the contributors. */
    policyIds: string[];
    /** Email addresses to which the invites should be sent. */
    emails: string[];
    /** Details explaining the purpose of the invite. */
    invitePurpose?: string | null;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface BulkSiteInviteResponse {
    /** Invites that were sent successfully. */
    invites?: SiteInvite$1[];
    /** Invites that failed. */
    failedEmails?: string[];
}
interface ResendSiteInviteRequest {
    /** Invite ID. */
    inviteId: string;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface AcceptSiteInviteRequest {
    inviteToken?: string;
}
interface AcceptSiteInviteResponse {
}
interface RevokeSiteInviteRequest {
    /** Invite ID. */
    inviteId: string;
}
interface RevokeSiteInviteResponse {
}
interface UpdateSiteInviteRequest {
    inviteId?: string;
    policyIds?: string[];
    staffId?: string | null;
}
interface UpdateSiteInviteResponse {
}
interface GetContributorLimitRequest {
}
interface GetContributorLimitResponse {
    contributorLimitation?: ContributorLimitation;
}
interface ContributorLimitation {
    contributorLimit?: number;
    leftInvites?: number;
}
interface ParseSiteInviteTokenRequest {
    inviteToken?: string;
}
interface ParseSiteInviteTokenResponse {
    inviteId?: string;
    siteId?: string;
    status?: InviteStatus$1;
}
interface SiteInviteNonNullableFields {
    _id: string;
    siteId: string;
    email: string;
    policyIds: string[];
    inviterId: string;
    status: InviteStatus$1;
    acceptLink: string;
    inviterAccountId: string;
}
interface BulkSiteInviteResponseNonNullableFields {
    invites: SiteInviteNonNullableFields[];
    failedEmails: string[];
}
interface SiteInviteResponseNonNullableFields {
    invite?: SiteInviteNonNullableFields;
}
interface BulkInviteOptions {
    /** Email addresses to which the invites should be sent. */
    emails: string[];
    /** Details explaining the purpose of the invite. */
    invitePurpose?: string | null;
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}
interface ResendInviteOptions {
    /** Language of emails to send. Relevant only for recipients that don't currently have a Wix user ID. Default: Site owner's language. */
    defaultEmailLanguage?: string | null;
}

declare function bulkInvite$1(httpClient: HttpClient): BulkInviteSignature;
interface BulkInviteSignature {
    /**
     * Creates and sends emails inviting potential site contributors to become contributors in the requesting site.
     * > **Important**: This call requires an account level API key and cannot be authenticated with the standard authorization header. API keys are currently available to selected beta users only.
     * @param - Role IDs, referred to as policy IDs, to assign to the contributors.
     */
    (policyIds: string[], options?: BulkInviteOptions | undefined): Promise<BulkSiteInviteResponse & BulkSiteInviteResponseNonNullableFields>;
}
declare function resendInvite$1(httpClient: HttpClient): ResendInviteSignature;
interface ResendInviteSignature {
    /**
     * Resends the email invitation to a potential site contributor.
     * > **Important**: This call requires an account level API key and cannot be authenticated with the standard authorization header. API keys are currently available to selected beta users only.
     * @param - Invite ID.
     */
    (inviteId: string, options?: ResendInviteOptions | undefined): Promise<SiteInviteResponse & SiteInviteResponseNonNullableFields>;
}
declare function revokeInvite$1(httpClient: HttpClient): RevokeInviteSignature;
interface RevokeInviteSignature {
    /**
     * Revokes a pending site contributor invite.
     * > **Important**: This call requires an account level API key and cannot be authenticated with the standard authorization header. API keys are currently available to selected beta users only.
     * @param - Invite ID.
     */
    (inviteId: string): Promise<void>;
}

declare const bulkInvite: MaybeContext<BuildRESTFunction<typeof bulkInvite$1> & typeof bulkInvite$1>;
declare const resendInvite: MaybeContext<BuildRESTFunction<typeof resendInvite$1> & typeof resendInvite$1>;
declare const revokeInvite: MaybeContext<BuildRESTFunction<typeof revokeInvite$1> & typeof revokeInvite$1>;

type index_d$2_AcceptSiteInviteRequest = AcceptSiteInviteRequest;
type index_d$2_AcceptSiteInviteResponse = AcceptSiteInviteResponse;
type index_d$2_BulkInviteOptions = BulkInviteOptions;
type index_d$2_BulkSiteInviteRequest = BulkSiteInviteRequest;
type index_d$2_BulkSiteInviteResponse = BulkSiteInviteResponse;
type index_d$2_BulkSiteInviteResponseNonNullableFields = BulkSiteInviteResponseNonNullableFields;
type index_d$2_ContributorLimitation = ContributorLimitation;
type index_d$2_CursorPaging = CursorPaging;
type index_d$2_GetContributorLimitRequest = GetContributorLimitRequest;
type index_d$2_GetContributorLimitResponse = GetContributorLimitResponse;
type index_d$2_GetSiteInviteRequest = GetSiteInviteRequest;
type index_d$2_GetSiteInviteResponse = GetSiteInviteResponse;
type index_d$2_GetSiteInvitesRequest = GetSiteInvitesRequest;
type index_d$2_GetSiteInvitesResponse = GetSiteInvitesResponse;
type index_d$2_Paging = Paging;
type index_d$2_ParseSiteInviteTokenRequest = ParseSiteInviteTokenRequest;
type index_d$2_ParseSiteInviteTokenResponse = ParseSiteInviteTokenResponse;
type index_d$2_QuerySiteInvitesRequest = QuerySiteInvitesRequest;
type index_d$2_QuerySiteInvitesResponse = QuerySiteInvitesResponse;
type index_d$2_QueryV2 = QueryV2;
type index_d$2_QueryV2PagingMethodOneOf = QueryV2PagingMethodOneOf;
type index_d$2_ResendInviteOptions = ResendInviteOptions;
type index_d$2_ResendSiteInviteRequest = ResendSiteInviteRequest;
type index_d$2_RevokeSiteInviteRequest = RevokeSiteInviteRequest;
type index_d$2_RevokeSiteInviteResponse = RevokeSiteInviteResponse;
type index_d$2_SiteInviteRequest = SiteInviteRequest;
type index_d$2_SiteInviteResponse = SiteInviteResponse;
type index_d$2_SiteInviteResponseNonNullableFields = SiteInviteResponseNonNullableFields;
type index_d$2_SortOrder = SortOrder;
declare const index_d$2_SortOrder: typeof SortOrder;
type index_d$2_Sorting = Sorting;
type index_d$2_UpdateSiteInviteRequest = UpdateSiteInviteRequest;
type index_d$2_UpdateSiteInviteResponse = UpdateSiteInviteResponse;
declare const index_d$2_bulkInvite: typeof bulkInvite;
declare const index_d$2_resendInvite: typeof resendInvite;
declare const index_d$2_revokeInvite: typeof revokeInvite;
declare namespace index_d$2 {
  export { type index_d$2_AcceptSiteInviteRequest as AcceptSiteInviteRequest, type index_d$2_AcceptSiteInviteResponse as AcceptSiteInviteResponse, type index_d$2_BulkInviteOptions as BulkInviteOptions, type index_d$2_BulkSiteInviteRequest as BulkSiteInviteRequest, type index_d$2_BulkSiteInviteResponse as BulkSiteInviteResponse, type index_d$2_BulkSiteInviteResponseNonNullableFields as BulkSiteInviteResponseNonNullableFields, type index_d$2_ContributorLimitation as ContributorLimitation, type index_d$2_CursorPaging as CursorPaging, type index_d$2_GetContributorLimitRequest as GetContributorLimitRequest, type index_d$2_GetContributorLimitResponse as GetContributorLimitResponse, type index_d$2_GetSiteInviteRequest as GetSiteInviteRequest, type index_d$2_GetSiteInviteResponse as GetSiteInviteResponse, type index_d$2_GetSiteInvitesRequest as GetSiteInvitesRequest, type index_d$2_GetSiteInvitesResponse as GetSiteInvitesResponse, InviteStatus$1 as InviteStatus, type index_d$2_Paging as Paging, type index_d$2_ParseSiteInviteTokenRequest as ParseSiteInviteTokenRequest, type index_d$2_ParseSiteInviteTokenResponse as ParseSiteInviteTokenResponse, type index_d$2_QuerySiteInvitesRequest as QuerySiteInvitesRequest, type index_d$2_QuerySiteInvitesResponse as QuerySiteInvitesResponse, type index_d$2_QueryV2 as QueryV2, type index_d$2_QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOf, type index_d$2_ResendInviteOptions as ResendInviteOptions, type index_d$2_ResendSiteInviteRequest as ResendSiteInviteRequest, type index_d$2_RevokeSiteInviteRequest as RevokeSiteInviteRequest, type index_d$2_RevokeSiteInviteResponse as RevokeSiteInviteResponse, type SiteInvite$1 as SiteInvite, type index_d$2_SiteInviteRequest as SiteInviteRequest, type index_d$2_SiteInviteResponse as SiteInviteResponse, type index_d$2_SiteInviteResponseNonNullableFields as SiteInviteResponseNonNullableFields, index_d$2_SortOrder as SortOrder, type index_d$2_Sorting as Sorting, type index_d$2_UpdateSiteInviteRequest as UpdateSiteInviteRequest, type index_d$2_UpdateSiteInviteResponse as UpdateSiteInviteResponse, index_d$2_bulkInvite as bulkInvite, index_d$2_resendInvite as resendInvite, index_d$2_revokeInvite as revokeInvite };
}

interface RefreshToken {
    token?: string;
}
/**
 * AuthorizeRequest is sent by the client to the authorization server to initiate
 * the authorization process.
 */
interface AuthorizeRequest {
    /** ID of the Wix OAuth app requesting authorization. */
    clientId?: string;
    /**
     * Desired authorization [grant type](https://auth0.com/docs/authenticate/protocols/oauth#grant-types).
     *
     * Supported values:
     * + `code`: The endpoint returns an authorization code that can be used to obtain an access token.
     */
    responseType?: string;
    /** URI to redirect the browser to after authentication and authorization. The browser is redirected to this URI whether the authentication and authorization process is successful or not. */
    redirectUri?: string | null;
    /**
     * Desired scope of access. If this field is left empty, only an access token is granted.
     * To received a refresh token, pass `offline_access` as the value of this field.
     */
    scope?: string | null;
    /**
     * A value used to confirm the state of an application before and after it makes an authorization
     * request. If a value for this field is set in the request, it's added to the `redirectUri` when the browser
     * is redirected there.
     * Learn more about [using the state parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).
     */
    state?: string;
    /**
     * esired response format.
     *
     * Supported values:
     * + `query`: The response parameters are encoded as query string parameters and added to the `redirectUri` when redirecting.
     * + `fragment`: The response parameters are encoded as URI fragment parameters and added to the `redirectUri` when redirecting.
     * + `web_message`: The response parameters are encoded as a JSON object and added to the body of a [web message response](https://datatracker.ietf.org/doc/html/draft-sakimura-oauth-wmrm-00).
     *
     * Default value: `query`
     */
    responseMode?: string | null;
    /**
     * Code challenge to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     */
    codeChallenge?: string | null;
    /**
     * Code challenge method to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     *
     * Supported values:
     * + `S256`: The code challenge is transformed using SHA-256 encyption.
     * + `S512`: The code challenge is transformed using SHA-512 encyption.
     */
    codeChallengeMethod?: string | null;
    /** Session token of the site visitor to authorize. */
    sessionToken?: string | null;
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface DeviceCodeRequest {
    /** The ID of the application that asks for authorization. */
    clientId?: string;
    /**
     * scope is a space-delimited string that specifies the requested scope of the
     * access request.
     */
    scope?: string | null;
}
interface DeviceCodeResponse {
    /** is the unique code for the device. When the user goes to the verification_uri in their browser-based device, this code will be bound to their session. */
    deviceCode?: string;
    /** contains the code that should be input at the verification_uri to authorize the device. */
    userCode?: string;
    /** contains the URL the user should visit to authorize the device. */
    verificationUri?: string;
    /** indicates the lifetime (in seconds) of the device_code and user_code. */
    expiresIn?: number;
    /** indicates the interval (in seconds) at which the app should poll the token URL to request a token. clients MUST use 5 as the default */
    interval?: number | null;
}
interface DeviceVerifyRequest {
    /** User code representing a currently authorizing device. */
    userCode?: string;
}
interface DeviceVerifyResponse {
}
interface DeviceVerifyV2Request {
    /** User code representing a currently authorizing device. */
    userCode?: string;
}
interface DeviceVerifyV2Response {
}
interface InvalidateUserCodeRequest {
    /** user code to invalidate. Only the authorizing identity is able to invalidate it. */
    userCode?: string;
}
interface InvalidateUserCodeResponse {
}
interface RevokeRefreshTokenRequest {
    /** The refresh token itself. Anyone with the token itself is able to revoke it. */
    token?: string;
}
interface RevokeRefreshTokenResponse {
}
interface TokenInfoResponse {
    active?: boolean;
    /** subject type. */
    subjectType?: SubjectType$1;
    /** subject id */
    subjectId?: string;
    /** Expiration time of the token */
    exp?: string | null;
    /** Issued time of the token */
    iat?: string | null;
    /** Client id */
    clientId?: string;
    /** Account id */
    accountId?: string | null;
    /** Site id */
    siteId?: string | null;
    /** Instance Id */
    instanceId?: string | null;
    /** Vendor Product Id */
    vendorProductId?: string | null;
}
declare enum SubjectType$1 {
    /** unknown subject type */
    UNKNOWN = "UNKNOWN",
    /** user subject type */
    USER = "USER",
    /** visitor subject type */
    VISITOR = "VISITOR",
    /** member subject type */
    MEMBER = "MEMBER",
    /** app subject type */
    APP = "APP"
}
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface HeadersEntryNonNullableFields {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields[];
}
interface TokenInfoResponseNonNullableFields {
    active: boolean;
    subjectType: SubjectType$1;
    subjectId: string;
    clientId: string;
}
interface TokenOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface TokenInfoOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}

declare function token$1(httpClient: HttpClient): TokenSignature;
interface TokenSignature {
    /**
     * Creates an access token.
     *
     *
     * The endpoint accepts raw HTTP requests. You must pass the request's body
     * parameters formatted as bytes in the raw HTTP request's `body` field,
     * following this template:
     * `{"grantType": "client_credentials", "client_id": "<APP_ID>", "client_secret": "<APP_SECRET_KEY>", "instance_id": "<INSTANCE_ID>"}`.
     *
     * When the call succeeds, Wix returns `{"statusCode": 200}` and the created access
     * token in the `body` field of the raw HTTP response.
     *
     * In case the call fails, Wix returns the relevant `4XX` error code in the raw
     * HTTP response's `statusCode` field and details
     * about the error in `body`. Error details follow the
     * [conventions of the Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6749#appendix-A.7).
     */
    (options?: TokenOptions | undefined): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
}
declare function tokenInfo$1(httpClient: HttpClient): TokenInfoSignature;
interface TokenInfoSignature {
    /**
     * Token Introspection Endpoint.
     */
    (options?: TokenInfoOptions | undefined): Promise<TokenInfoResponse & TokenInfoResponseNonNullableFields>;
}

declare const token: MaybeContext<BuildRESTFunction<typeof token$1> & typeof token$1>;
declare const tokenInfo: MaybeContext<BuildRESTFunction<typeof tokenInfo$1> & typeof tokenInfo$1>;

type index_d$1_ActionEvent = ActionEvent;
type index_d$1_AuthorizeRequest = AuthorizeRequest;
type index_d$1_DeviceCodeRequest = DeviceCodeRequest;
type index_d$1_DeviceCodeResponse = DeviceCodeResponse;
type index_d$1_DeviceVerifyRequest = DeviceVerifyRequest;
type index_d$1_DeviceVerifyResponse = DeviceVerifyResponse;
type index_d$1_DeviceVerifyV2Request = DeviceVerifyV2Request;
type index_d$1_DeviceVerifyV2Response = DeviceVerifyV2Response;
type index_d$1_DomainEvent = DomainEvent;
type index_d$1_DomainEventBodyOneOf = DomainEventBodyOneOf;
type index_d$1_Empty = Empty;
type index_d$1_EntityCreatedEvent = EntityCreatedEvent;
type index_d$1_EntityDeletedEvent = EntityDeletedEvent;
type index_d$1_EntityUpdatedEvent = EntityUpdatedEvent;
type index_d$1_HeadersEntry = HeadersEntry;
type index_d$1_InvalidateUserCodeRequest = InvalidateUserCodeRequest;
type index_d$1_InvalidateUserCodeResponse = InvalidateUserCodeResponse;
type index_d$1_PathParametersEntry = PathParametersEntry;
type index_d$1_QueryParametersEntry = QueryParametersEntry;
type index_d$1_RawHttpRequest = RawHttpRequest;
type index_d$1_RawHttpResponse = RawHttpResponse;
type index_d$1_RawHttpResponseNonNullableFields = RawHttpResponseNonNullableFields;
type index_d$1_RefreshToken = RefreshToken;
type index_d$1_RestoreInfo = RestoreInfo;
type index_d$1_RevokeRefreshTokenRequest = RevokeRefreshTokenRequest;
type index_d$1_RevokeRefreshTokenResponse = RevokeRefreshTokenResponse;
type index_d$1_TokenInfoOptions = TokenInfoOptions;
type index_d$1_TokenInfoResponse = TokenInfoResponse;
type index_d$1_TokenInfoResponseNonNullableFields = TokenInfoResponseNonNullableFields;
type index_d$1_TokenOptions = TokenOptions;
declare const index_d$1_token: typeof token;
declare const index_d$1_tokenInfo: typeof tokenInfo;
declare namespace index_d$1 {
  export { type index_d$1_ActionEvent as ActionEvent, type index_d$1_AuthorizeRequest as AuthorizeRequest, type index_d$1_DeviceCodeRequest as DeviceCodeRequest, type index_d$1_DeviceCodeResponse as DeviceCodeResponse, type index_d$1_DeviceVerifyRequest as DeviceVerifyRequest, type index_d$1_DeviceVerifyResponse as DeviceVerifyResponse, type index_d$1_DeviceVerifyV2Request as DeviceVerifyV2Request, type index_d$1_DeviceVerifyV2Response as DeviceVerifyV2Response, type index_d$1_DomainEvent as DomainEvent, type index_d$1_DomainEventBodyOneOf as DomainEventBodyOneOf, type index_d$1_Empty as Empty, type index_d$1_EntityCreatedEvent as EntityCreatedEvent, type index_d$1_EntityDeletedEvent as EntityDeletedEvent, type index_d$1_EntityUpdatedEvent as EntityUpdatedEvent, type index_d$1_HeadersEntry as HeadersEntry, type index_d$1_InvalidateUserCodeRequest as InvalidateUserCodeRequest, type index_d$1_InvalidateUserCodeResponse as InvalidateUserCodeResponse, type index_d$1_PathParametersEntry as PathParametersEntry, type index_d$1_QueryParametersEntry as QueryParametersEntry, type index_d$1_RawHttpRequest as RawHttpRequest, type index_d$1_RawHttpResponse as RawHttpResponse, type index_d$1_RawHttpResponseNonNullableFields as RawHttpResponseNonNullableFields, type index_d$1_RefreshToken as RefreshToken, type index_d$1_RestoreInfo as RestoreInfo, type index_d$1_RevokeRefreshTokenRequest as RevokeRefreshTokenRequest, type index_d$1_RevokeRefreshTokenResponse as RevokeRefreshTokenResponse, SubjectType$1 as SubjectType, type index_d$1_TokenInfoOptions as TokenInfoOptions, type index_d$1_TokenInfoResponse as TokenInfoResponse, type index_d$1_TokenInfoResponseNonNullableFields as TokenInfoResponseNonNullableFields, type index_d$1_TokenOptions as TokenOptions, index_d$1_token as token, index_d$1_tokenInfo as tokenInfo };
}

interface Contributor {
    /** Contributor's metadata. */
    metaData?: PersonMetaData;
    /** Whether the contributor account is a team account. */
    isTeam?: boolean | null;
    /** Date that the contributor joined the site. */
    joinedAt?: Date | null;
    /** Email address that received the invite. */
    invitedEmail?: string | null;
    /** Whether the contributor account is a client account. */
    isClient?: boolean | null;
    /**
     * Contributor's user ID.
     * @readonly
     */
    _id?: string;
}
interface PersonMetaData {
    /** Contributor's account ID. */
    _id?: string;
    /** Contributor's full name. */
    fullName?: string | null;
    /** URL for contributor's profile image. */
    imageUrl?: string | null;
    /** Contributor's email address. */
    email?: string | null;
    /** Contributor's access to assets and their assigned role (`policy`) for that asset. */
    assignments?: Assignment[];
}
interface Assignment {
    /** Role assigned to the user. */
    policy?: AssignedPolicy;
    /** Unique ID for this specific assignment. */
    assignmentId?: string;
    /** Identity assigned to the asset in an assignment, referred to as subject. Supported subjects include user IDs, account IDs, and app IDs. */
    subject?: Subject;
}
interface AssignedPolicy {
    /** Role ID. */
    policyId?: string;
    /** Role title. */
    title?: string | null;
    /** Role description. */
    description?: string | null;
}
interface Restriction extends RestrictionRestrictionsOneOf {
    /**
     * Deprecated.
     * @deprecated
     */
    resource?: Resource;
    /** List of conditions restricting the user's access. Currently only folder conditions are supported. */
    conditions?: Conditions;
    /** Site where the assignment restrictions apply. */
    site?: SiteRestriction;
}
/** @oneof */
interface RestrictionRestrictionsOneOf {
    /**
     * Deprecated.
     * @deprecated
     */
    resource?: Resource;
    /** List of conditions restricting the user's access. Currently only folder conditions are supported. */
    conditions?: Conditions;
    /** Site where the assignment restrictions apply. */
    site?: SiteRestriction;
}
interface Resource {
    /** Resource type. */
    resourceType?: ResourceType;
    /** Resource ID. */
    _id?: string;
    value?: string | null;
}
declare enum ResourceType {
    UNKNOWN_RESOURCE_TYPE = "UNKNOWN_RESOURCE_TYPE",
    SITE = "SITE"
}
interface Conditions {
    /** List of conditions. */
    conditions?: Condition[];
}
interface Condition {
    /** Condition type. */
    conditionType?: ConditionAttributeType;
    /** Condition ID. */
    _id?: string;
    /** Expected value of the condition. When `conditionType` = "FOLDER", this is the folder path. */
    value?: string | null;
}
declare enum ConditionAttributeType {
    UNKNOWN_CONDITION_TYPE = "UNKNOWN_CONDITION_TYPE",
    FOLDER = "FOLDER"
}
interface SiteRestriction {
    /** Site ID. */
    _id?: string;
    /** Site name. */
    value?: string | null;
}
interface CompanionResource {
    /** Asset ID (referred to here as resource ID). */
    _id?: string;
    /** Asset type (referred to here as resource type). as predefined in the authorization system */
    resourceType?: string;
}
interface Subject {
    /** ID of identity assigned to the asset. */
    _id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectType;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext;
}
declare enum SubjectType {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
interface SubjectContext {
    _id?: string;
    contextType?: SubjectContextType;
}
declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
interface GetAppContributorsRequest {
    appId?: string;
    /** The locale of the request. Defaults to en-us. */
    locale?: string | null;
}
interface GetAppContributorsResponse {
    contributors?: Contributor[];
    invites?: AppInvite[];
}
interface AppInvite {
    /** @readonly */
    _id?: string;
    /** TODO: amitis - remove this comment after the next merge */
    destEmail?: string;
    /** @readonly */
    status?: string;
    /** @readonly */
    acceptLink?: string;
    invitePurpose?: string | null;
    policies?: AssignedPolicy[];
    /** @readonly */
    expirationDate?: Date | null;
    /** @readonly */
    dateCreated?: Date | null;
    /** @readonly */
    dateUpdated?: Date | null;
}
interface GetSiteContributorsRequest {
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface GetSiteContributorsResponse {
    users?: User[];
    teams?: Team[];
    invites?: SiteInvite[];
    policies?: Policy[];
    permissions?: string[];
    userId?: string;
    loggedInAccountId?: string;
    pendingOwner?: PendingOwner;
    contributorLimit?: ContributorLimit;
    predefinedRoles?: PredefinedRoles;
}
interface User {
    /** User ID. */
    _id?: string;
    /**
     * Deprecated.
     * @deprecated
     */
    roles?: string[];
    /** User's email address. */
    email?: string;
    /** User's name. */
    name?: Name;
    /** URL to user's profile image, when provided. */
    profileImage?: string | null;
    /** Date the user joined the team. */
    joinedTeamAt?: Date | null;
    /**
     * Deprecated.
     * @deprecated
     */
    policyIds?: string[];
    /** Resources the user can access. */
    assignments?: Assignment[];
}
interface Name {
    /** User's first name. */
    firstName?: string;
    /** User's last name. */
    lastName?: string;
}
interface Team {
    accountId?: string;
    accountInfo?: AccountInfo;
    policyIds?: string[];
    joinedAt?: Date | null;
}
interface AccountInfo {
    accountName?: string;
    accountImage?: string;
    isTeam?: boolean;
}
interface SiteInvite {
    /**
     * Invite ID.
     * @readonly
     */
    _id?: string;
    /**
     * Site ID the user is invited to as a collaborator.
     * @readonly
     */
    siteId?: string;
    /** Email address where the invite was sent. */
    email?: string;
    /** Role IDs included in the invite. */
    policyIds?: string[];
    /**
     * Deprecated. Use `inviterAccountId`.
     * @readonly
     * @deprecated
     */
    inviterId?: string;
    /**
     * Invite Status.
     *
     * Supported values:
     * - **Pending:** The invite has been sent and is valid, waiting for the user's response.
     * - **Used:** The invite has been accepted.
     * - **Deleted:** The invite has been deleted or revoked.
     * - **Declined:** The user declined the invite.
     * - **Expired:** The invite has expired without being accepted.
     */
    status?: InviteStatus;
    /** Link to accept the invite. */
    acceptLink?: string;
    /**
     * Inviting account ID.
     * @readonly
     */
    inviterAccountId?: string;
    /**
     * Account ID that accepted the invite. Populated only once the invite is accepted.
     * @readonly
     */
    acceptedByAccountId?: string | null;
    /** Date the invite was created. */
    dateCreated?: Date | null;
    /** User's Wix Bookings staff ID, if relevant. */
    staffId?: string | null;
    /** Invite expiration date */
    expirationDate?: Date | null;
}
/** Invite status stating whether the invite was accepted, waiting to be accepted, deleted etc.. */
declare enum InviteStatus {
    Pending = "Pending",
    Used = "Used",
    Deleted = "Deleted",
    Declined = "Declined",
    Expired = "Expired"
}
interface Policy {
    _id?: string;
    description?: string | null;
    name?: string | null;
    isCustom?: boolean;
    scopes?: string[];
}
interface PendingOwner {
    email?: string;
    expirationDate?: Date | null;
    acceptLink?: string;
}
interface ContributorLimit {
    contributorLimit?: number;
}
interface PredefinedRoles {
    roles?: PredefinedRole[];
}
interface PredefinedRole {
    titleKey?: string;
    roles?: Role[];
    title?: string | null;
    areaId?: string;
}
interface Role {
    _id?: string;
    deprecatedKey?: string;
    /** @deprecated */
    titleKey?: string;
    /** @deprecated */
    descriptionKey?: string;
    deprecated?: boolean;
    restrictFromLevel?: string;
    experiments?: string[];
    appDefIds?: string[];
    title?: string | null;
    description?: string | null;
    isCustom?: boolean;
    scopes?: string[];
    availableResourceTypes?: ResourceType[];
    availableConditions?: ConditionAttributeType[];
    limitToEditorTypes?: string[];
}
interface GetSiteContributorsV2Request {
    /** The locale of the request. Defaults to en-us. */
    locale?: string | null;
}
interface GetSiteContributorsV2Response {
    /** List of contributors of the given site. */
    contributors?: Contributor[];
    /** List of invites to contribute to the given site. */
    invites?: SiteInvite[];
    /** Quota information for contributors on the given site. */
    contributorsQuota?: ContributorsQuota;
}
interface ContributorsQuota extends ContributorsQuotaOptionsOneOf {
    /** Limited contributors quota details. */
    limitedOptions?: LimitedOptions;
    /** Type of contributors quota */
    type?: Type;
}
/** @oneof */
interface ContributorsQuotaOptionsOneOf {
    /** Limited contributors quota details. */
    limitedOptions?: LimitedOptions;
}
/** Enum to represent different types of contributors quota. */
declare enum Type {
    UNKNOWN = "UNKNOWN",
    LIMITED = "LIMITED",
    UNLIMITED = "UNLIMITED"
}
/** Details for a limited contributors quota. */
interface LimitedOptions {
    /** Maximum number of contributors allowed. */
    limit?: number;
    /** Number of accepted or pending invitations. */
    used?: number;
}
interface HandleSiteTransferRequest {
    originalOwnerAccountId?: string;
    newOwnerAccountId?: string;
    metaSiteId?: string;
    keepOriginalOwnerAsContributor?: boolean;
}
interface HandleSiteTransferResponse {
}
interface GetCurrentUserRolesRequest {
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface GetCurrentUserRolesResponse {
    roles?: LocalizedRole[];
}
interface LocalizedRole {
    name?: string;
    description?: string | null;
}
interface BulkGetUserRolesOnSiteRequest {
    users?: UserSubject[];
    /** The locale of the request. Defaults to en-us */
    locale?: string | null;
}
interface UserSubject {
    userId?: string;
    accountId?: string;
}
interface BulkGetUserRolesOnSiteResponse {
    userRoles?: UserLocalizedRoles[];
}
interface UserLocalizedRoles {
    user?: UserSubject;
    roles?: LocalizedRole[];
}
interface ChangeContributorRoleRequest {
    /** Contributor's account ID. */
    accountId: string;
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment[];
}
interface SiteRoleAssignment {
    /** Role ID. Sometimes referred to as policy ID. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for a list of available roles. */
    roleId?: string;
    /**
     * Assignment ID mapping the role to the contributor on the site.
     * @readonly
     */
    assignmentId?: string;
}
interface ChangeContributorRoleResponse {
    /** New roles assigned to the contributor on the site. */
    newAssignedRoles?: SiteRoleAssignment[];
}
interface QuerySiteContributorsRequest {
    filter?: QuerySiteContributorsFilter;
}
interface QuerySiteContributorsFilter {
    /** Role IDs (referred to here as policy IDs) to return. See [Roles and Permissions](https://support.wix.com/en/article/roles-permissions-overview) for available roles. */
    policyIds?: string[];
}
declare enum FieldSet {
    UNKNOWN = "UNKNOWN",
    /** Include only `account_id` and `account_owner_id` fields. */
    META_DATA = "META_DATA"
}
interface QuerySiteContributorsResponse {
    /** List of site contributors. */
    contributors?: ContributorV2[];
}
interface ContributorV2 {
    /** Contributor's account ID. */
    accountId?: string | null;
    /** User ID of the owner of the account that the contributor has joined. */
    accountOwnerId?: string | null;
}
interface GetContributorsQuotaRequest {
}
interface GetContributorsQuotaResponse {
    /** Quota information for contributors on the given site. */
    contributorsQuota?: ContributorsQuota;
}
interface SiteRoleAssignmentNonNullableFields {
    roleId: string;
    assignmentId: string;
}
interface ChangeContributorRoleResponseNonNullableFields {
    newAssignedRoles: SiteRoleAssignmentNonNullableFields[];
}
interface ChangeRoleOptions {
    /** New roles to assign to the contributor on the site. */
    newRoles: SiteRoleAssignment[];
}
interface QuerySiteContributorsOptions {
    filter?: QuerySiteContributorsFilter;
}

declare function changeRole$1(httpClient: HttpClient): ChangeRoleSignature;
interface ChangeRoleSignature {
    /**
     * Overrides all the roles of a contributor for the specified site.
     * @param - Contributor's account ID.
     */
    (accountId: string, options: ChangeRoleOptions): Promise<ChangeContributorRoleResponse & ChangeContributorRoleResponseNonNullableFields>;
}
declare function querySiteContributors$1(httpClient: HttpClient): QuerySiteContributorsSignature;
interface QuerySiteContributorsSignature {
    /**
     * Retrieves a list of contributors for the specified site, given the provided filters.
     */
    (options?: QuerySiteContributorsOptions | undefined): Promise<QuerySiteContributorsResponse>;
}

declare const changeRole: MaybeContext<BuildRESTFunction<typeof changeRole$1> & typeof changeRole$1>;
declare const querySiteContributors: MaybeContext<BuildRESTFunction<typeof querySiteContributors$1> & typeof querySiteContributors$1>;

type index_d_AccountInfo = AccountInfo;
type index_d_AppInvite = AppInvite;
type index_d_AssignedPolicy = AssignedPolicy;
type index_d_Assignment = Assignment;
type index_d_BulkGetUserRolesOnSiteRequest = BulkGetUserRolesOnSiteRequest;
type index_d_BulkGetUserRolesOnSiteResponse = BulkGetUserRolesOnSiteResponse;
type index_d_ChangeContributorRoleRequest = ChangeContributorRoleRequest;
type index_d_ChangeContributorRoleResponse = ChangeContributorRoleResponse;
type index_d_ChangeContributorRoleResponseNonNullableFields = ChangeContributorRoleResponseNonNullableFields;
type index_d_ChangeRoleOptions = ChangeRoleOptions;
type index_d_CompanionResource = CompanionResource;
type index_d_Condition = Condition;
type index_d_ConditionAttributeType = ConditionAttributeType;
declare const index_d_ConditionAttributeType: typeof ConditionAttributeType;
type index_d_Conditions = Conditions;
type index_d_Contributor = Contributor;
type index_d_ContributorLimit = ContributorLimit;
type index_d_ContributorV2 = ContributorV2;
type index_d_ContributorsQuota = ContributorsQuota;
type index_d_ContributorsQuotaOptionsOneOf = ContributorsQuotaOptionsOneOf;
type index_d_FieldSet = FieldSet;
declare const index_d_FieldSet: typeof FieldSet;
type index_d_GetAppContributorsRequest = GetAppContributorsRequest;
type index_d_GetAppContributorsResponse = GetAppContributorsResponse;
type index_d_GetContributorsQuotaRequest = GetContributorsQuotaRequest;
type index_d_GetContributorsQuotaResponse = GetContributorsQuotaResponse;
type index_d_GetCurrentUserRolesRequest = GetCurrentUserRolesRequest;
type index_d_GetCurrentUserRolesResponse = GetCurrentUserRolesResponse;
type index_d_GetSiteContributorsRequest = GetSiteContributorsRequest;
type index_d_GetSiteContributorsResponse = GetSiteContributorsResponse;
type index_d_GetSiteContributorsV2Request = GetSiteContributorsV2Request;
type index_d_GetSiteContributorsV2Response = GetSiteContributorsV2Response;
type index_d_HandleSiteTransferRequest = HandleSiteTransferRequest;
type index_d_HandleSiteTransferResponse = HandleSiteTransferResponse;
type index_d_InviteStatus = InviteStatus;
declare const index_d_InviteStatus: typeof InviteStatus;
type index_d_LimitedOptions = LimitedOptions;
type index_d_LocalizedRole = LocalizedRole;
type index_d_Name = Name;
type index_d_PendingOwner = PendingOwner;
type index_d_PersonMetaData = PersonMetaData;
type index_d_Policy = Policy;
type index_d_PredefinedRole = PredefinedRole;
type index_d_PredefinedRoles = PredefinedRoles;
type index_d_QuerySiteContributorsFilter = QuerySiteContributorsFilter;
type index_d_QuerySiteContributorsOptions = QuerySiteContributorsOptions;
type index_d_QuerySiteContributorsRequest = QuerySiteContributorsRequest;
type index_d_QuerySiteContributorsResponse = QuerySiteContributorsResponse;
type index_d_Resource = Resource;
type index_d_ResourceType = ResourceType;
declare const index_d_ResourceType: typeof ResourceType;
type index_d_Restriction = Restriction;
type index_d_RestrictionRestrictionsOneOf = RestrictionRestrictionsOneOf;
type index_d_Role = Role;
type index_d_SiteInvite = SiteInvite;
type index_d_SiteRestriction = SiteRestriction;
type index_d_SiteRoleAssignment = SiteRoleAssignment;
type index_d_Subject = Subject;
type index_d_SubjectContext = SubjectContext;
type index_d_SubjectContextType = SubjectContextType;
declare const index_d_SubjectContextType: typeof SubjectContextType;
type index_d_SubjectType = SubjectType;
declare const index_d_SubjectType: typeof SubjectType;
type index_d_Team = Team;
type index_d_Type = Type;
declare const index_d_Type: typeof Type;
type index_d_User = User;
type index_d_UserLocalizedRoles = UserLocalizedRoles;
type index_d_UserSubject = UserSubject;
declare const index_d_changeRole: typeof changeRole;
declare const index_d_querySiteContributors: typeof querySiteContributors;
declare namespace index_d {
  export { type index_d_AccountInfo as AccountInfo, type index_d_AppInvite as AppInvite, type index_d_AssignedPolicy as AssignedPolicy, type index_d_Assignment as Assignment, type index_d_BulkGetUserRolesOnSiteRequest as BulkGetUserRolesOnSiteRequest, type index_d_BulkGetUserRolesOnSiteResponse as BulkGetUserRolesOnSiteResponse, type index_d_ChangeContributorRoleRequest as ChangeContributorRoleRequest, type index_d_ChangeContributorRoleResponse as ChangeContributorRoleResponse, type index_d_ChangeContributorRoleResponseNonNullableFields as ChangeContributorRoleResponseNonNullableFields, type index_d_ChangeRoleOptions as ChangeRoleOptions, type index_d_CompanionResource as CompanionResource, type index_d_Condition as Condition, index_d_ConditionAttributeType as ConditionAttributeType, type index_d_Conditions as Conditions, type index_d_Contributor as Contributor, type index_d_ContributorLimit as ContributorLimit, type index_d_ContributorV2 as ContributorV2, type index_d_ContributorsQuota as ContributorsQuota, type index_d_ContributorsQuotaOptionsOneOf as ContributorsQuotaOptionsOneOf, index_d_FieldSet as FieldSet, type index_d_GetAppContributorsRequest as GetAppContributorsRequest, type index_d_GetAppContributorsResponse as GetAppContributorsResponse, type index_d_GetContributorsQuotaRequest as GetContributorsQuotaRequest, type index_d_GetContributorsQuotaResponse as GetContributorsQuotaResponse, type index_d_GetCurrentUserRolesRequest as GetCurrentUserRolesRequest, type index_d_GetCurrentUserRolesResponse as GetCurrentUserRolesResponse, type index_d_GetSiteContributorsRequest as GetSiteContributorsRequest, type index_d_GetSiteContributorsResponse as GetSiteContributorsResponse, type index_d_GetSiteContributorsV2Request as GetSiteContributorsV2Request, type index_d_GetSiteContributorsV2Response as GetSiteContributorsV2Response, type index_d_HandleSiteTransferRequest as HandleSiteTransferRequest, type index_d_HandleSiteTransferResponse as HandleSiteTransferResponse, index_d_InviteStatus as InviteStatus, type index_d_LimitedOptions as LimitedOptions, type index_d_LocalizedRole as LocalizedRole, type index_d_Name as Name, type index_d_PendingOwner as PendingOwner, type index_d_PersonMetaData as PersonMetaData, type index_d_Policy as Policy, type index_d_PredefinedRole as PredefinedRole, type index_d_PredefinedRoles as PredefinedRoles, type index_d_QuerySiteContributorsFilter as QuerySiteContributorsFilter, type index_d_QuerySiteContributorsOptions as QuerySiteContributorsOptions, type index_d_QuerySiteContributorsRequest as QuerySiteContributorsRequest, type index_d_QuerySiteContributorsResponse as QuerySiteContributorsResponse, type index_d_Resource as Resource, index_d_ResourceType as ResourceType, type index_d_Restriction as Restriction, type index_d_RestrictionRestrictionsOneOf as RestrictionRestrictionsOneOf, type index_d_Role as Role, type index_d_SiteInvite as SiteInvite, type index_d_SiteRestriction as SiteRestriction, type index_d_SiteRoleAssignment as SiteRoleAssignment, type index_d_Subject as Subject, type index_d_SubjectContext as SubjectContext, index_d_SubjectContextType as SubjectContextType, index_d_SubjectType as SubjectType, type index_d_Team as Team, index_d_Type as Type, type index_d_User as User, type index_d_UserLocalizedRoles as UserLocalizedRoles, type index_d_UserSubject as UserSubject, index_d_changeRole as changeRole, index_d_querySiteContributors as querySiteContributors };
}

export { index_d$3 as accountInvite, index_d$6 as authentication, index_d$1 as oauth, index_d$5 as recovery, index_d as rolesManagement, index_d$2 as siteInvite, index_d$4 as verification };
