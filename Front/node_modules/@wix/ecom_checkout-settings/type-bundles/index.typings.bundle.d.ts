interface CheckoutSettings {
    /** Checkout policies. */
    checkoutPolicies?: CheckoutPolicies;
    /** Settings that apply to checkout fields and the checkout process. */
    checkoutFields?: CheckoutFields;
    /** Checkout brand settings. */
    checkoutBrand?: CheckoutBrand;
    /**
     * Date and time the checkout settings were created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the checkout settings were updated.
     * @readonly
     */
    _updatedDate?: Date | null;
}
interface CheckoutPolicies {
    /** Terms and conditions. */
    termsAndConditions?: TermsAndConditionsPolicy;
    /** Privacy policy. */
    privacyPolicy?: PrivacyPolicy;
    /** Return policy. */
    returnPolicy?: ReturnPolicy;
    /** Digital item policy. */
    digitalItemPolicy?: DigitalItemPolicy;
    /** "Contact us" information. */
    contactUs?: ContactUsPolicy;
    /** Custom policy. */
    customPolicy?: CustomCheckoutPolicy;
}
interface TermsAndConditionsPolicy {
    /**
     * Whether the terms & conditions policy is visible to the customer in the checkout page. <br><br>
     *
     * Default: `false`
     */
    visible?: boolean | null;
    /** Terms and conditions policy content. */
    content?: string | null;
}
interface PrivacyPolicy {
    /**
     * Whether the privacy policy is visible to the customer in the checkout page. <br><br>
     *
     * Default: `false`
     */
    visible?: boolean | null;
    /** Privacy policy content. */
    content?: string | null;
}
interface ReturnPolicy {
    /**
     * Whether the return policy is visible to the customer in the checkout page. <br><br>
     *
     * Default: `false`
     */
    visible?: boolean | null;
    /** Return policy content. */
    content?: string | null;
}
interface DigitalItemPolicy {
    /**
     * Whether the digital item policy is visible to the customer in the checkout page. <br><br>
     *
     * Default: `false`
     */
    visible?: boolean | null;
    /** Digital item policy content. */
    content?: string | null;
}
interface ContactUsPolicy {
    /**
     * Whether the contact us policy is visible to the customer in the checkout page. <br><br>
     *
     * Default: `false`
     */
    visible?: boolean | null;
    /** Contact us policy content. */
    content?: string | null;
}
interface CustomCheckoutPolicy {
    /**
     * Whether the policy is visible to the customer on the checkout page.
     * Default: `false`.
     */
    visible?: boolean | null;
    /** Policy content. */
    content?: string | null;
    /** Policy title. */
    title?: string | null;
}
interface CheckoutFields {
    /**
     * Subscription checkbox.
     * Default:
     * - `visible`: `false`,
     * - `checkedByDefault`: `false`
     */
    subscriptionCheckbox?: CheckboxField;
    /**
     * Policy agreement checkbox.
     * Default:
     * - `visible`: `true`,
     * - `checkedByDefault`: `true`
     */
    policyAgreementCheckbox?: CheckboxField;
    /**
     * Whether the ability to redeem a gift card is enabled.
     * Default: `false`.
     */
    giftCardRedeemEnabled?: boolean | null;
    /**
     * Whether to allow for MIT transactions.
     * Default: `false`.
     */
    mitEnabled?: boolean | null;
    /**
     * Whether to allow for Auth & Capture transactions. <br><br>
     *
     * Default: `false`
     */
    delayCaptureEnabled?: boolean | null;
    /**
     * Whether to automatically capture the transaction before the authorization expires.
     *
     * Default: `true`
     * >**Note:** this setting is only relevant when `delay_capture_enabled: true`.
     */
    captureBeforeExpiryEnabled?: boolean | null;
}
interface CheckboxField {
    /** Whether the checkbox is visible to the customer. */
    visible?: boolean | null;
    /** Whether the checkbox is checked by default. */
    checkedByDefault?: boolean | null;
}
interface CheckoutBrand {
    /** Checkout header. */
    header?: CheckoutHeader;
}
interface CheckoutHeader {
    /**
     * Textual content to be included in the header (e.g. Business Name)
     * TODO: update maxLength validation once limitation is known
     */
    text?: string | null;
    /** Specifications for when a logo is included in the header. */
    logo?: Logo;
    /**
     * Alignment within the header.
     *
     * >**Note:** `SIDE` alignment is decided depending on the locale's language. For example, scripts like Hebrew and Arabic will automatically align right-to-left.
     */
    alignment?: Alignment;
    /**
     * Whether to display the 'Checkout' label within the header.
     * Depending on the locale, the label may be translated.
     */
    displayCheckoutLabel?: boolean | null;
}
interface Logo {
    /** Size of the logo. */
    size?: LogoSize;
}
declare enum LogoSize {
    UNKNOWN_LOGO_SIZE = "UNKNOWN_LOGO_SIZE",
    SMALL = "SMALL",
    MEDIUM = "MEDIUM",
    LARGE = "LARGE"
}
declare enum Alignment {
    UNKNOWN_ALIGNMENT = "UNKNOWN_ALIGNMENT",
    SIDE = "SIDE",
    CENTER = "CENTER"
}
interface GetCheckoutSettingsRequest {
}
interface GetCheckoutSettingsResponse {
    /** Checkout settings. */
    checkoutSettings?: CheckoutSettings;
}
interface UpdateCheckoutSettingsRequest {
    /** Checkout settings to update. */
    checkoutSettings: CheckoutSettings;
}
interface UpdateCheckoutSettingsResponse {
    /** The updated checkout settings. */
    checkoutSettings?: CheckoutSettings;
}
interface ListCheckoutSettingsRequest {
}
interface ListCheckoutSettingsResponse {
    /** List of retrieved checkout settings. */
    checkoutSettings?: CheckoutSettings[];
}
interface GiftCardProviderWasProvisioned {
    /** The gift card provider which was installed */
    providerAppDefId?: string;
    providerInstanceId?: string;
}
interface Empty {
}
interface DeleteCheckoutSettingsRequest {
}
interface DeleteCheckoutSettingsResponse {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface LogoNonNullableFields {
    image: string;
    size: LogoSize;
}
interface CheckoutHeaderNonNullableFields {
    logo?: LogoNonNullableFields;
    alignment: Alignment;
}
interface CheckoutBrandNonNullableFields {
    header?: CheckoutHeaderNonNullableFields;
}
interface CheckoutSettingsNonNullableFields {
    checkoutBrand?: CheckoutBrandNonNullableFields;
}
interface GetCheckoutSettingsResponseNonNullableFields {
    checkoutSettings?: CheckoutSettingsNonNullableFields;
}
interface UpdateCheckoutSettingsResponseNonNullableFields {
    checkoutSettings?: CheckoutSettingsNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface CheckoutSettingsUpdatedEnvelope {
    entity: CheckoutSettings;
    metadata: EventMetadata;
}
/**
 * Triggered when checkout settings are updated.
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId ECOM.READ_CHECKOUT_SETTINGS
 * @webhook
 * @eventType wix.ecom.v1.checkout_settings_updated
 * @documentationMaturity preview
 */
declare function onCheckoutSettingsUpdated(handler: (event: CheckoutSettingsUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Retrieves the sites' checkout settings.
 *
 *
 * The `getCheckoutSettings()` function returns a Promise that resolves to checkout settings.
 * @public
 * @documentationMaturity preview
 * @permissionId ECOM.READ_CHECKOUT_SETTINGS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Read eCommerce - all read permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.READ-ECOM
 * @permissionScope Read Orders
 * @permissionScopeId SCOPE.DC-STORES.READ-ORDERS
 * @permissionScope Read Stores - all read permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.READ-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns The requested checkout settings.
 */
declare function getCheckoutSettings(): Promise<GetCheckoutSettingsResponse & GetCheckoutSettingsResponseNonNullableFields>;
/**
 * Updates the sites' checkout settings.
 *
 *
 * The `updateCheckoutSettings()` function returns a Promise that resolves to the newly updated checkout settings.
 * @param checkoutSettings - Checkout settings to update.
 * @public
 * @documentationMaturity preview
 * @requiredField checkoutSettings
 * @permissionId ECOM.UPDATE_CHECKOUT_SETTINGS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @returns The updated checkout settings.
 */
declare function updateCheckoutSettings(checkoutSettings: CheckoutSettings): Promise<UpdateCheckoutSettingsResponse & UpdateCheckoutSettingsResponseNonNullableFields>;

export { type ActionEvent, Alignment, type BaseEventMetadata, type CheckboxField, type CheckoutBrand, type CheckoutFields, type CheckoutHeader, type CheckoutPolicies, type CheckoutSettings, type CheckoutSettingsUpdatedEnvelope, type ContactUsPolicy, type CustomCheckoutPolicy, type DeleteCheckoutSettingsRequest, type DeleteCheckoutSettingsResponse, type DigitalItemPolicy, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type GetCheckoutSettingsRequest, type GetCheckoutSettingsResponse, type GetCheckoutSettingsResponseNonNullableFields, type GiftCardProviderWasProvisioned, type IdentificationData, type IdentificationDataIdOneOf, type ListCheckoutSettingsRequest, type ListCheckoutSettingsResponse, type Logo, LogoSize, type MessageEnvelope, type PrivacyPolicy, type RestoreInfo, type ReturnPolicy, type TermsAndConditionsPolicy, type UpdateCheckoutSettingsRequest, type UpdateCheckoutSettingsResponse, type UpdateCheckoutSettingsResponseNonNullableFields, WebhookIdentityType, getCheckoutSettings, onCheckoutSettingsUpdated, updateCheckoutSettings };
