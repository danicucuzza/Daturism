interface RegisterV2Request$1 {
    /** Identifier of registering member. */
    loginId: LoginId$1;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile$1;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken$1[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId$1 extends LoginIdTypeOneOf$1 {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf$1 {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile$1 {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus$1;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField$1[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail$1[];
    /** List of profile phone numbers. */
    phonesV2?: Phone$1[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper$1[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus$1 {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField$1 {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue$1;
}
interface V1CustomValue$1 extends V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
/** @oneof */
interface V1CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue$1;
    /** Map value. */
    mapValue?: V1MapValue$1;
}
interface V1ListValue$1 {
    /** Custom value. */
    value?: V1CustomValue$1[];
}
interface V1MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue$1>;
}
interface SecondaryEmail$1 {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag$1;
}
declare enum EmailTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone$1 {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag$1;
}
declare enum PhoneTag$1 {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper$1 {
    /** Address. */
    address?: Address$1;
    /** Address tag. */
    tag?: AddressTag$1;
}
/** Physical address */
interface Address$1 {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag$1 {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken$1 extends CaptchaTokenTokenOneOf$1 {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf$1 {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse$1 {
    /** The current state of the login or registration process. */
    state?: StateType$1;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity$1;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue$1>;
}
declare enum StateType$1 {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity$1 {
    /** Identity ID */
    id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier$1[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection$1[];
    /** Identity profile. */
    identityProfile?: IdentityProfile$1;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata$1;
    /** Identity email address. */
    email?: Email$1;
    /** Identity's current status. */
    status?: StatusV2$1;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor$1[];
}
interface Identifier$1 extends IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf$1 {
    email?: string;
    userName?: string;
}
interface Connection$1 extends ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
/** @oneof */
interface ConnectionTypeOneOf$1 {
    /** IDP connection. */
    idpConnection?: IdpConnection$1;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection$1;
}
interface IdpConnection$1 {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection$1 {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata$1 {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email$1 {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2$1 {
    name?: StatusName$1;
    reasons?: Reason$1[];
}
declare enum StatusName$1 {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason$1 {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor$1 {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType$1;
    /** Factor status. */
    status?: Status$1;
}
declare enum FactorType$1 {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status$1 {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue$1 extends CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
/** @oneof */
interface CustomValueValueOneOf$1 {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue$1;
    /** Map value. */
    mapValue?: MapValue$1;
}
interface ListValue$1 {
    /** Custom value. */
    value?: CustomValue$1[];
}
interface MapValue$1 {
    /** Mapped custom value. */
    value?: Record<string, CustomValue$1>;
}
interface LoginV2Request$1 {
    /** Identifier of identity logging in. */
    loginId: LoginId$1;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken$1[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest$1 {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse$1 {
}
interface LoginWithIdpConnectionRequest$1 {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType$1;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType$1 {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse$1 {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry$1[];
}
interface HeadersEntry$1 {
    key?: string;
    value?: string;
}
interface RawHttpRequest$1 {
    body?: Uint8Array;
    pathParams?: PathParametersEntry$1[];
    queryParams?: QueryParametersEntry$1[];
    headers?: HeadersEntry$1[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry$1 {
    key?: string;
    value?: string;
}
interface QueryParametersEntry$1 {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest$1 {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest$1 {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest$1 {
    /** the identifier of the identity */
    loginId: LoginId$1;
    /** profile of the identity */
    profile?: IdentityProfile$1;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse$1 {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity$1;
}
/** logout request payload */
interface LogoutRequest$1 {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields$1 {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields$1 {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields$1 {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields$1 {
    idpConnection?: IdpConnectionNonNullableFields$1;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields$1;
}
interface V1ListValueNonNullableFields$1 {
    value: V1CustomValueNonNullableFields$1[];
}
interface V1CustomValueNonNullableFields$1 {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields$1;
}
interface CustomFieldNonNullableFields$1 {
    name: string;
    value?: V1CustomValueNonNullableFields$1;
}
interface SecondaryEmailNonNullableFields$1 {
    email: string;
    tag: EmailTag$1;
}
interface PhoneNonNullableFields$1 {
    phone: string;
    tag: PhoneTag$1;
}
interface AddressWrapperNonNullableFields$1 {
    tag: AddressTag$1;
}
interface IdentityProfileNonNullableFields$1 {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus$1;
    customFields: CustomFieldNonNullableFields$1[];
    secondaryEmails: SecondaryEmailNonNullableFields$1[];
    phonesV2: PhoneNonNullableFields$1[];
    addresses: AddressWrapperNonNullableFields$1[];
}
interface MetadataNonNullableFields$1 {
    tags: string[];
}
interface EmailNonNullableFields$1 {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields$1 {
    name: StatusName$1;
    reasons: Reason$1[];
}
interface FactorNonNullableFields$1 {
    factorId: string;
    type: FactorType$1;
    status: Status$1;
}
interface IdentityNonNullableFields$1 {
    identifiers: IdentifierNonNullableFields$1[];
    connections: ConnectionNonNullableFields$1[];
    identityProfile?: IdentityProfileNonNullableFields$1;
    metadata?: MetadataNonNullableFields$1;
    email?: EmailNonNullableFields$1;
    status?: StatusV2NonNullableFields$1;
    factors: FactorNonNullableFields$1[];
}
interface StateMachineResponseNonNullableFields$1 {
    state: StateType$1;
    identity?: IdentityNonNullableFields$1;
}
interface HeadersEntryNonNullableFields$1 {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields$1 {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields$1[];
}
interface SignOnResponseNonNullableFields$1 {
    sessionToken: string;
    identity?: IdentityNonNullableFields$1;
}

interface RegisterV2Request {
    /** Identifier of registering member. */
    loginId: LoginId;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId extends LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken extends CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse {
    /** The current state of the login or registration process. */
    state?: StateType;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue>;
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor[];
}
interface Identifier extends IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
declare enum FactorType {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse {
}
interface LoginWithIdpConnectionRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity;
}
/** logout request payload */
interface LogoutRequest {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    identifiers: IdentifierNonNullableFields[];
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
interface StateMachineResponseNonNullableFields {
    state: StateType;
    identity?: IdentityNonNullableFields;
}
interface HeadersEntryNonNullableFields {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields[];
}
interface SignOnResponseNonNullableFields {
    sessionToken: string;
    identity?: IdentityNonNullableFields;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function registerV2(): __PublicMethodMetaInfo<'POST', {}, RegisterV2Request, RegisterV2Request$1, StateMachineResponse & StateMachineResponseNonNullableFields, StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;
declare function loginV2(): __PublicMethodMetaInfo<'POST', {}, LoginV2Request, LoginV2Request$1, StateMachineResponse & StateMachineResponseNonNullableFields, StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;
declare function changePassword(): __PublicMethodMetaInfo<'POST', {}, ChangePasswordRequest, ChangePasswordRequest$1, ChangePasswordResponse, ChangePasswordResponse$1>;
declare function loginWithIdpConnection(): __PublicMethodMetaInfo<'GET', {
    tenantId: string;
    idpConnectionId: string;
}, LoginWithIdpConnectionRequest, LoginWithIdpConnectionRequest$1, RawHttpResponse & RawHttpResponseNonNullableFields, RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
declare function loginWithIdpConnectionCallback(): __PublicMethodMetaInfo<'GET', {
    tenantType: string;
    tenantId: string;
    idpConnectionId: string;
}, RawHttpRequest, RawHttpRequest$1, RawHttpResponse & RawHttpResponseNonNullableFields, RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
declare function loginCallback(): __PublicMethodMetaInfo<'GET', {}, LoginCallbackRequest, LoginCallbackRequest$1, RawHttpResponse & RawHttpResponseNonNullableFields, RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;
declare function loginWithIdpConnectionTokenParams(): __PublicMethodMetaInfo<'POST', {}, LoginWithIdpConnectionTokenParamsRequest, LoginWithIdpConnectionTokenParamsRequest$1, StateMachineResponse & StateMachineResponseNonNullableFields, StateMachineResponse$1 & StateMachineResponseNonNullableFields$1>;
declare function signOn(): __PublicMethodMetaInfo<'POST', {}, SignOnRequest, SignOnRequest$1, SignOnResponse & SignOnResponseNonNullableFields, SignOnResponse$1 & SignOnResponseNonNullableFields$1>;
declare function logout(): __PublicMethodMetaInfo<'GET', {}, LogoutRequest, LogoutRequest$1, RawHttpResponse & RawHttpResponseNonNullableFields, RawHttpResponse$1 & RawHttpResponseNonNullableFields$1>;

export { type __PublicMethodMetaInfo, changePassword, loginCallback, loginV2, loginWithIdpConnection, loginWithIdpConnectionCallback, loginWithIdpConnectionTokenParams, logout, registerV2, signOn };
