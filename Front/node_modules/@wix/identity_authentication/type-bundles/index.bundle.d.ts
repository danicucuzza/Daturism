type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface Authentication {
}
interface RegisterV2Request {
    /** Identifier of registering member. */
    loginId: LoginId;
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId extends LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf {
    /** Login email address. */
    email?: string;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface CaptchaToken extends CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf {
    Recaptcha?: string;
    InvisibleRecaptcha?: string;
    NoCaptcha?: string;
}
interface StateMachineResponse {
    /** The current state of the login or registration process. */
    state?: StateType;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue>;
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor[];
}
interface Identifier extends IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
declare enum FactorType {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse {
}
interface LoginWithIdpConnectionRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The type of the tenant the caller wants to login into */
    tenantType: TenantType;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity;
}
/** logout request payload */
interface LogoutRequest {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}
interface IdentifierNonNullableFields {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    identifiers: IdentifierNonNullableFields[];
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
interface StateMachineResponseNonNullableFields {
    state: StateType;
    identity?: IdentityNonNullableFields;
}
interface HeadersEntryNonNullableFields {
    key: string;
    value: string;
}
interface RawHttpResponseNonNullableFields {
    body: Uint8Array;
    headers: HeadersEntryNonNullableFields[];
}
interface SignOnResponseNonNullableFields {
    sessionToken: string;
    identity?: IdentityNonNullableFields;
}
interface RegisterV2Options {
    /** Password of registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginV2Options {
    /** Password of the identity logging in. */
    password?: string;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data, relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginWithIdpConnectionIdentifiers {
    /** The id of the tenant the caller wants to login into */
    tenantId: string;
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId: string;
}
interface LoginWithIdpConnectionOptions {
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId: string;
    encryptionKey: string;
    visitorId?: string | null;
    bsi?: string | null;
}
interface LoginWithIdpConnectionCallbackOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface LoginCallbackOptions {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsOptions {
    /** The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnOptions {
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface LogoutOptions {
    /** redirect after logout */
    postLogoutRedirectUri?: string | null;
    /** caller identifier */
    clientId?: string | null;
}

declare function registerV2$1(httpClient: HttpClient): RegisterV2Signature;
interface RegisterV2Signature {
    /**
     * Registers a new member.
     *
     * Typically, after a sucessful registration, you generate and use member tokens for the
     * registered member so that subsequent API calls are called as part of a member session.
     *
     * If the email used to register the member already exists as a contact email, the registering
     * member need to verify the email address using a code that is sent to the address.
     * @param - Identifier of registering member.
     */
    (loginId: LoginId, options?: RegisterV2Options | undefined): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
}
declare function loginV2$1(httpClient: HttpClient): LoginV2Signature;
interface LoginV2Signature {
    /**
     * Logs in an existing user.
     *
     * Typically, after a sucessful login, you generate and use member tokens for the
     * logged-in member so that subsequent API calls are called as part of a member session.
     * @param - Identifier of identity logging in.
     */
    (loginId: LoginId, options?: LoginV2Options | undefined): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
}
declare function changePassword$1(httpClient: HttpClient): ChangePasswordSignature;
interface ChangePasswordSignature {
    /**
     * Changes the password of a logged in user.
     * @param - The new password to set for the logged in user
     */
    (newPassword: string): Promise<void>;
}
declare function loginWithIdpConnection$1(httpClient: HttpClient): LoginWithIdpConnectionSignature;
interface LoginWithIdpConnectionSignature {
    /** @param - The type of the tenant the caller wants to login into */
    (identifiers: LoginWithIdpConnectionIdentifiers, tenantType: TenantType, options?: LoginWithIdpConnectionOptions | undefined): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
}
declare function loginWithIdpConnectionCallback$1(httpClient: HttpClient): LoginWithIdpConnectionCallbackSignature;
interface LoginWithIdpConnectionCallbackSignature {
    /**
     * REQUIRES path params `tenant_type`, `tenant_id` and `idp_connection_id`
     */
    (options?: LoginWithIdpConnectionCallbackOptions | undefined): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
}
declare function loginCallback$1(httpClient: HttpClient): LoginCallbackSignature;
interface LoginCallbackSignature {
    /** */
    (options?: LoginCallbackOptions | undefined): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
}
declare function loginWithIdpConnectionTokenParams$1(httpClient: HttpClient): LoginWithIdpConnectionTokenParamsSignature;
interface LoginWithIdpConnectionTokenParamsSignature {
    /** */
    (options?: LoginWithIdpConnectionTokenParamsOptions | undefined): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
}
declare function signOn$1(httpClient: HttpClient): SignOnSignature;
interface SignOnSignature {
    /** @param - the identifier of the identity */
    (loginId: LoginId, options?: SignOnOptions | undefined): Promise<SignOnResponse & SignOnResponseNonNullableFields>;
}
declare function logout$1(httpClient: HttpClient): LogoutSignature;
interface LogoutSignature {
    /**
     * Logs out a member.
     */
    (options?: LogoutOptions | undefined): Promise<RawHttpResponse & RawHttpResponseNonNullableFields>;
}

declare const registerV2: MaybeContext<BuildRESTFunction<typeof registerV2$1> & typeof registerV2$1>;
declare const loginV2: MaybeContext<BuildRESTFunction<typeof loginV2$1> & typeof loginV2$1>;
declare const changePassword: MaybeContext<BuildRESTFunction<typeof changePassword$1> & typeof changePassword$1>;
declare const loginWithIdpConnection: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnection$1> & typeof loginWithIdpConnection$1>;
declare const loginWithIdpConnectionCallback: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnectionCallback$1> & typeof loginWithIdpConnectionCallback$1>;
declare const loginCallback: MaybeContext<BuildRESTFunction<typeof loginCallback$1> & typeof loginCallback$1>;
declare const loginWithIdpConnectionTokenParams: MaybeContext<BuildRESTFunction<typeof loginWithIdpConnectionTokenParams$1> & typeof loginWithIdpConnectionTokenParams$1>;
declare const signOn: MaybeContext<BuildRESTFunction<typeof signOn$1> & typeof signOn$1>;
declare const logout: MaybeContext<BuildRESTFunction<typeof logout$1> & typeof logout$1>;

export { type Address, AddressTag, type AddressWrapper, type Authentication, type AuthenticatorConnection, type CaptchaToken, type CaptchaTokenTokenOneOf, type ChangePasswordRequest, type ChangePasswordResponse, type Connection, type ConnectionTypeOneOf, type CustomField, type CustomValue, type CustomValueValueOneOf, type Email, EmailTag, type Factor, FactorType, type HeadersEntry, type Identifier, type IdentifierValueOneOf, type Identity, type IdentityProfile, type IdpConnection, type ListValue, type LoginCallbackOptions, type LoginCallbackRequest, type LoginId, type LoginIdTypeOneOf, type LoginV2Options, type LoginV2Request, type LoginWithIdpConnectionCallbackOptions, type LoginWithIdpConnectionIdentifiers, type LoginWithIdpConnectionOptions, type LoginWithIdpConnectionRequest, type LoginWithIdpConnectionTokenParamsOptions, type LoginWithIdpConnectionTokenParamsRequest, type LogoutOptions, type LogoutRequest, type MapValue, type Metadata, type PathParametersEntry, type Phone, PhoneTag, PrivacyStatus, type QueryParametersEntry, type RawHttpRequest, type RawHttpResponse, type RawHttpResponseNonNullableFields, Reason, type RegisterV2Options, type RegisterV2Request, type SecondaryEmail, type SignOnOptions, type SignOnRequest, type SignOnResponse, type SignOnResponseNonNullableFields, type StateMachineResponse, type StateMachineResponseNonNullableFields, StateType, Status, StatusName, type StatusV2, TenantType, type V1CustomValue, type V1CustomValueValueOneOf, type V1ListValue, type V1MapValue, changePassword, loginCallback, loginV2, loginWithIdpConnection, loginWithIdpConnectionCallback, loginWithIdpConnectionTokenParams, logout, registerV2, signOn };
