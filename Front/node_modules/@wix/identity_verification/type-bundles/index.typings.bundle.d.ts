interface StartResponse {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target;
}
declare enum Target {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
interface VerifyRequest {
    /** the code to verify */
    code?: string;
    /** the identifier of the verification process */
    verificationId?: string;
}
interface VerifyResponse {
}
interface VerifyDuringAuthenticationRequest {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse {
    /** The current state of the login or registration process. */
    state?: StateType;
    /** If state is `SUCCESS`, a session token. */
    sessionToken?: string | null;
    /** A token representing the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identing of the current member. */
    identity?: Identity;
    /** additional_data = 5; //TBD */
    additionalData?: Record<string, CustomValue>;
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** The operation completed successfully. */
    SUCCESS = "SUCCESS",
    /** State that indicates that the member needs owner approval to proceed, available action in: OwnerApprovalStateHandler */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /**
     * State that indicates a member waiting for verification, available action are: verifyDuringAuthentication or resendDuringAuthentication
     * https://dev.wix.com/docs/rest/api-reference/auth-management/verification-v1/verify-during-authentication
     */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** State that indicates checking that the status is not one of the `invalidStates` before proceeding. */
    STATUS_CHECK = "STATUS_CHECK",
    REQUIRE_MFA = "REQUIRE_MFA"
}
interface Identity {
    /** Identity ID */
    _id?: string | null;
    /**
     * Identifiers
     * @deprecated Identifiers
     * @replacedBy email
     * @targetRemovalDate 2023-05-01
     */
    identifiers?: Identifier[];
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes.
     * For an update operation to succeed, you MUST pass the latest revision.
     */
    revision?: string | null;
    /**
     * The time this identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * The time this identity was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** filled by pre registered spi */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity factors.
     * @readonly
     */
    factors?: Factor[];
}
interface Identifier extends IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
/** @oneof */
interface IdentifierValueOneOf {
    email?: string;
    userName?: string;
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /** IDP connection ID. */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /** Authenticator connection ID. */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /** List of profile labels. */
    labels?: string[];
    /** Profile language. */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatus;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /** Company name. */
    company?: string | null;
    /** Position within company. */
    position?: string | null;
    /** Profile birthdate - ISO-8601 extended local date format (YYYY-MM-DD). */
    birthdate?: string | null;
}
declare enum PrivacyStatus {
    UNDEFINED = "UNDEFINED",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE"
}
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: V1ListValue;
    /** Map value. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /** Email address. */
    email?: string;
    /** Email tag. */
    tag?: EmailTag;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
interface Phone {
    /** Phone country code. */
    countryCode?: string | null;
    /** Phone number. */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTag;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTag;
}
/** Physical address */
interface Address {
    /** Country code. */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
interface Metadata {
    /**
     * represents general tags such as "isOwner", "isContributor"
     * @readonly
     */
    tags?: string[];
}
interface Email {
    address?: string;
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusName;
    reasons?: Reason[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
interface Factor {
    /** Factor ID. */
    factorId?: string;
    /** Factor type. */
    type?: FactorType;
    /** Factor status. */
    status?: Status;
}
declare enum FactorType {
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    PASSWORD = "PASSWORD",
    SMS = "SMS",
    CALL = "CALL",
    EMAIL = "EMAIL",
    TOTP = "TOTP",
    PUSH = "PUSH"
}
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface ResendDuringAuthenticationRequest {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StartResponseNonNullableFields {
    verificationId: string;
}
interface IdentifierNonNullableFields {
    email: string;
    userName: string;
}
interface IdpConnectionNonNullableFields {
    idpConnectionId: string;
    idpUserId: string;
}
interface AuthenticatorConnectionNonNullableFields {
    authenticatorConnectionId: string;
    reEnrollmentRequired: boolean;
}
interface ConnectionNonNullableFields {
    idpConnection?: IdpConnectionNonNullableFields;
    authenticatorConnection?: AuthenticatorConnectionNonNullableFields;
}
interface V1ListValueNonNullableFields {
    value: V1CustomValueNonNullableFields[];
}
interface V1CustomValueNonNullableFields {
    strValue: string;
    numValue: number;
    listValue?: V1ListValueNonNullableFields;
}
interface CustomFieldNonNullableFields {
    name: string;
    value?: V1CustomValueNonNullableFields;
}
interface SecondaryEmailNonNullableFields {
    email: string;
    tag: EmailTag;
}
interface PhoneNonNullableFields {
    phone: string;
    tag: PhoneTag;
}
interface AddressWrapperNonNullableFields {
    tag: AddressTag;
}
interface IdentityProfileNonNullableFields {
    emails: string[];
    phones: string[];
    labels: string[];
    privacyStatus: PrivacyStatus;
    customFields: CustomFieldNonNullableFields[];
    secondaryEmails: SecondaryEmailNonNullableFields[];
    phonesV2: PhoneNonNullableFields[];
    addresses: AddressWrapperNonNullableFields[];
}
interface MetadataNonNullableFields {
    tags: string[];
}
interface EmailNonNullableFields {
    address: string;
    isVerified: boolean;
}
interface StatusV2NonNullableFields {
    name: StatusName;
    reasons: Reason[];
}
interface FactorNonNullableFields {
    factorId: string;
    type: FactorType;
    status: Status;
}
interface IdentityNonNullableFields {
    identifiers: IdentifierNonNullableFields[];
    connections: ConnectionNonNullableFields[];
    identityProfile?: IdentityProfileNonNullableFields;
    metadata?: MetadataNonNullableFields;
    email?: EmailNonNullableFields;
    status?: StatusV2NonNullableFields;
    factors: FactorNonNullableFields[];
}
interface StateMachineResponseNonNullableFields {
    state: StateType;
    identity?: IdentityNonNullableFields;
}
/**
 * starts a verification process
 * example: sends a code to the identity's email
 * @public
 * @documentationMaturity preview
 * @permissionId IAM.START
 */
declare function start(options?: StartOptions): Promise<StartResponse & StartResponseNonNullableFields>;
interface StartOptions {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     */
    identityId?: string | null;
    /** the delivery target */
    target?: Target;
}
/**
 * Continues the registration process when a member is required to verify an email address
 * using a verification code received by email.
 *
 * Email verification is required when the registering member is already listed as a contact.
 *
 * Typically, after a successful verification, you generate and use member tokens for the
 * registered member so that subsequent API calls are called as part of a member session.
 * @param code - The code to verify.
 * @public
 * @documentationMaturity preview
 * @requiredField code
 * @requiredField options
 * @requiredField options.stateToken
 */
declare function verifyDuringAuthentication(code: string, options: VerifyDuringAuthenticationOptions): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;
interface VerifyDuringAuthenticationOptions {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
/**
 * Resend the verification email and continue the registration process when a member is required to verify an email address
 * using a verification code received by email.
 * @param stateToken - A state token representing the `REQUIRE_EMAIL_VERIFICATION` state.
 * @public
 * @documentationMaturity preview
 * @requiredField stateToken
 * @permissionId IAM.RESEND_DURING_AUTHENTICATION
 */
declare function resendDuringAuthentication(stateToken: string): Promise<StateMachineResponse & StateMachineResponseNonNullableFields>;

export { type Address, AddressTag, type AddressWrapper, type AuthenticatorConnection, type Connection, type ConnectionTypeOneOf, type CustomField, type CustomValue, type CustomValueValueOneOf, type Email, EmailTag, type Factor, FactorType, type Identifier, type IdentifierValueOneOf, type Identity, type IdentityProfile, type IdpConnection, type ListValue, type MapValue, type Metadata, type Phone, PhoneTag, PrivacyStatus, Reason, type ResendDuringAuthenticationRequest, type SecondaryEmail, type StartOptions, type StartRequest, type StartResponse, type StartResponseNonNullableFields, type StateMachineResponse, type StateMachineResponseNonNullableFields, StateType, Status, StatusName, type StatusV2, Target, type V1CustomValue, type V1CustomValueValueOneOf, type V1ListValue, type V1MapValue, type VerifyDuringAuthenticationOptions, type VerifyDuringAuthenticationRequest, type VerifyRequest, type VerifyResponse, resendDuringAuthentication, start, verifyDuringAuthentication };
