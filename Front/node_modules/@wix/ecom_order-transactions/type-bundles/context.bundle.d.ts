type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface OrderTransactions {
    /** Order ID. */
    orderId?: string;
    /** Record of payments made to the merchant. */
    payments?: Payment[];
    /** Record of refunds made to the buyer. */
    refunds?: Refund[];
}
interface Payment extends PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /** Wix Payments order ID. */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `offline_payment` is `false`.
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     */
    paymentMethod?: string | null;
    /** Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments. */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
    /** Whether there is a payment agreement that allows for future charges. */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
}
/** @oneof */
interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
interface CreditCardPaymentMethodDetails {
    /** The last 4 digits of the card number. */
    lastFourDigits?: string | null;
    /** Card issuer's brand. */
    brand?: string | null;
}
interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: ScheduledAction;
}
interface AuthorizationCapture {
    /**
     * Capture ID.
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatus;
    /** Amount of this capture */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Whether capture operation still in progress */
    PENDING = "PENDING",
    /** The capture operation was succeeded */
    SUCCEEDED = "SUCCEEDED",
    /** The capture operation was failed */
    FAILED = "FAILED"
}
interface Price {
    /** Amount. */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
interface AuthorizationActionFailureDetails {
    failureCode?: string;
}
interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatus;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: Reason;
}
declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Whether void operation still in progress */
    PENDING = "PENDING",
    /** The void operation was succeeded */
    SUCCEEDED = "SUCCEEDED",
    /** The void operation was failed */
    FAILED = "FAILED"
}
/**
 * Reason the authorization was voided.
 *
 * + `MANUAL`: Authorization was voided by user.
 * + `SCHEDULED`: Authorization passed execution date.
 */
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    MANUAL = "MANUAL",
    SCHEDULED = "SCHEDULED"
}
interface ScheduledAction {
    /** type of the action */
    actionType?: ActionType;
    /** the date and time of the action */
    executionDate?: Date | null;
}
declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
interface GiftCardPaymentDetails {
    /** Gift card payment ID. */
    giftCardPaymentId?: string;
    /** ID of the app that created the gift card. */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
interface MembershipPaymentDetails {
    /** Membership ID. */
    membershipId?: string;
    /** ID of the line item this membership applies to. */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatus;
    /** Membership name. */
    name?: MembershipName;
    /** The transaction ID in the membership system. Can be used to void the transaction. */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /** ID of the application providing this payment option. */
    providerAppId?: string;
}
declare enum MembershipPaymentStatus {
    /** CHARGED - Payment was charged */
    CHARGED = "CHARGED",
    /** CHARGE_FAILED - The attempt to charge that payment have failed, for example due to lack of credits */
    CHARGE_FAILED = "CHARGE_FAILED"
}
interface MembershipName {
    /** Membership name. */
    original?: string;
    /** Translated membership name. Defaults to `original` when not provided. */
    translated?: string | null;
}
interface Refund {
    /**
     * Refund ID.
     * @readonly
     */
    _id?: string;
    /** List of transactions. */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /** Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
}
interface RefundTransaction {
    /** ID of the payment associated with this refund. */
    paymentId?: string;
    /** Refund amount. */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatus;
    /**
     * Payment gateway's refund ID. This ID can be used with the Wix Payments [Transactions API](https://dev.wix.com/docs/rest/api-reference/wix-payments/transactions/introduction).
     * This field is only returned when the value of `external_refund` is `false`.
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /** Whether refund was made externally and manually on the payment provider's side. */
    externalRefund?: boolean;
}
/**
 * Refund transaction status.
 * + `PENDING`: Refund was initiated on payment provider side. PENDING status was assigned by provider.
 * + `SUCCEEDED`: Refund transaction succeeded.
 * + `FAILED`: Refund transaction failed.
 * + `SCHEDULED`: Refund request acknowledged, and will be executed soon.
 * + `STARTED`: Refund was initiated on payment provider side.
 */
declare enum RefundStatus {
    PENDING = "PENDING",
    SUCCEEDED = "SUCCEEDED",
    FAILED = "FAILED",
    SCHEDULED = "SCHEDULED",
    STARTED = "STARTED"
}
/** Business model of a refund request */
interface RefundDetails {
    /** Order line item IDs and quantities that were refunded. */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /** Reason for the refund, provided by customer (optional). */
    reason?: string | null;
}
interface RefundItem {
    /** Line item ID the refunded line item. */
    lineItemId?: string;
    /** Line item quantity refunded. */
    quantity?: number;
}
interface LineItemRefund {
}
interface AdditionalFeeRefund {
}
interface ShippingRefund {
}
interface AggregatedRefundSummary {
}
interface SnapshotMessage {
    _id?: string;
    opType?: number;
}
interface IndexingMessage {
    _id?: string;
    opType?: number;
    requiredVersions?: string[];
}
interface DiffmatokyPayload {
    left?: string;
    right?: string;
    compareChannel?: string;
    entityId?: string;
    errorInformation?: ErrorInformation;
    tags?: string[];
}
interface ErrorInformation {
    stackTrace?: string;
}
interface OrderRefunded {
    /**
     * Refund ID.
     * @readonly
     */
    refundId?: string;
    /**
     * Refunded order data.
     * @readonly
     */
    order?: Order;
}
interface Order {
    /**
     * Order ID (auto-generated upon order creation).
     * @readonly
     */
    _id?: string | null;
    /**
     * Order number displayed in the owner's store (auto-generated).
     * @readonly
     */
    number?: number;
    /**
     * Order creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /** Buyer information. */
    buyerInfo?: BuyerInfo;
    /** Currency used for the pricing of this order in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format. */
    currency?: string | null;
    /** Weight unit used in this store. */
    weightUnit?: WeightUnit;
    /** Totals for order's line items. */
    totals?: Totals;
    /** Billing information. */
    billingInfo?: BillingInfo;
    /** Shipping information. */
    shippingInfo?: ShippingInfo;
    /** A note added by the buyer. */
    buyerNote?: string | null;
    /**
     * Deprecated.
     * @readonly
     * @deprecated
     */
    read?: boolean;
    /**
     * Whether or not the order was archived.
     * @readonly
     */
    archived?: boolean;
    /** Current status of the payment. */
    paymentStatus?: PaymentStatus;
    /**
     * Order's current fulfillment status (whether the order received a tracking number or was delivered/picked up).
     * @readonly
     */
    fulfillmentStatus?: FulfillmentStatus;
    /** Line items ordered. */
    lineItems?: LineItem[];
    /**
     * Log of updates related to the order.
     * @readonly
     */
    activities?: Activity[];
    /** Invoice information. */
    invoiceInfo?: V2InvoiceInfo;
    /**
     * Order fulfillment information.
     * @readonly
     */
    fulfillments?: Fulfillment[];
    /** Discount information. */
    discount?: Discount;
    /** Custom field information. */
    customField?: CustomField;
    /** Shopping cart ID. */
    cartId?: string | null;
    /**
     * Language for communication with the buyer. Defaults to the site language.
     * For a site that supports multiple languages, this is the language the buyer selected.
     */
    buyerLanguage?: string | null;
    /** Information about the sales channel that submitted this order. */
    channelInfo?: ChannelInfo;
    /**
     * Identity of the order's initiator.
     * @readonly
     */
    enteredBy?: EnteredBy;
    /**
     * Date and time of latest update.
     * @readonly
     */
    lastUpdated?: Date | null;
    /** Subscription information. */
    subscriptionInfo?: SubscriptionInfo;
    /**
     * Order’s unique numeric ID.
     * Primarily used for sorting and filtering when crawling all orders.
     * @readonly
     */
    numericId?: string;
    /**
     * Refund information.
     * @readonly
     */
    refunds?: V2Refund[];
}
/** Buyer Info */
interface BuyerInfo {
    /** Wix customer ID */
    _id?: string | null;
    /**
     * Deprecated (use identityType instead)
     * @readonly
     * @deprecated
     */
    type?: IdentityType;
    /** Customer type */
    identityType?: IdentityType;
    /**
     * Customer's first name
     * @readonly
     */
    firstName?: string;
    /**
     * Customer's last name
     * @readonly
     */
    lastName?: string;
    /**
     * Customer's phone number
     * @readonly
     */
    phone?: string | null;
    /**
     * Customer's email address
     * @readonly
     */
    email?: string;
}
declare enum IdentityType {
    UNSPECIFIED_IDENTITY_TYPE = "UNSPECIFIED_IDENTITY_TYPE",
    /** Site member */
    MEMBER = "MEMBER",
    /** Contact */
    CONTACT = "CONTACT"
}
declare enum WeightUnit {
    /** Weight unit can't be classified, due to an error */
    UNSPECIFIED_WEIGHT_UNIT = "UNSPECIFIED_WEIGHT_UNIT",
    /** Kilograms */
    KG = "KG",
    /** Pounds */
    LB = "LB"
}
interface Totals {
    /** Subtotal of all the line items, before tax. */
    subtotal?: string;
    /** Total shipping price, before tax. */
    shipping?: string | null;
    /** Total tax. */
    tax?: string | null;
    /** Total calculated discount value. */
    discount?: string | null;
    /** Total price charged. */
    total?: string;
    /**
     * Total items weight.
     * @readonly
     */
    weight?: string;
    /**
     * Total number of line items.
     * @readonly
     */
    quantity?: number;
    /**
     * Total refund.
     * @readonly
     */
    refund?: string | null;
    /** Total calculated gift card value. */
    giftCard?: string | null;
}
interface BillingInfo {
    /** Payment method used for this order */
    paymentMethod?: string | null;
    /**
     * Deprecated (use paymentProviderTransactionId instead)
     * @readonly
     * @deprecated
     */
    externalTransactionId?: string | null;
    /** Transaction ID from payment provider (e.g., PayPal, Square, Stripe) transaction ID */
    paymentProviderTransactionId?: string | null;
    /** Transaction ID from payment gateway (e.g., Wix Payments) */
    paymentGatewayTransactionId?: string | null;
    /** Full billing address */
    address?: Address;
    /**
     * Payment date
     * @readonly
     */
    paidDate?: Date | null;
    /** Whether order can be refunded by payment provider (manually or automatic) */
    refundableByPaymentProvider?: boolean | null;
}
interface Address extends AddressAddressLine1OptionsOneOf {
    /** Address line 1 (free text) */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
    /** Addressee name */
    fullName?: FullName;
    /** Country code (2 letters) */
    country?: string | null;
    /** State or district */
    subdivision?: string | null;
    /** City name */
    city?: string | null;
    /** ZIP/postal code */
    zipCode?: string | null;
    /** Phone number */
    phone?: string | null;
    /** Company name */
    company?: string | null;
    /** Email address */
    email?: string | null;
    /** address line */
    addressLine2?: string | null;
    /** Tax information (for Brazil only) */
    vatId?: VatId;
}
/** @oneof */
interface AddressAddressLine1OptionsOneOf {
    /** Address line 1 (free text) */
    addressLine1?: string;
    /** Address line 1 (street) */
    street?: Street;
}
interface FullName {
    /** Customer's first name */
    firstName?: string;
    /** Customer's last name */
    lastName?: string;
}
interface Street {
    /** Street number */
    number?: string;
    /** Street name */
    name?: string;
}
interface VatId {
    /** Customer's tax ID. */
    number?: string;
    /**
     * Tax type.
     * + `CPF`: For individual tax payers.
     * + `CNPJ`: For corporations.
     */
    type?: VatType;
}
/** Brazilian tax info types */
declare enum VatType {
    /** When the tax info type can't be classified, due to an error */
    UNSPECIFIED_TAX_TYPE = "UNSPECIFIED_TAX_TYPE",
    /** CPF - for individual tax payers */
    CPF = "CPF",
    /** CNPJ - for corporations */
    CNPJ = "CNPJ"
}
interface ShippingInfo extends ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
    /** Shipping option name. */
    deliveryOption?: string;
    /** Shipping option delivery time. */
    estimatedDeliveryTime?: string | null;
    /**
     * Deprecated - Latest expected delivery date.
     * @deprecated
     */
    deliverByDate?: Date | null;
    /** Shipping region. */
    shippingRegion?: string | null;
    /**
     * Unique code of provided shipping option. For example, `"usps_std_overnight"`.
     * @readonly
     */
    code?: string | null;
}
/** @oneof */
interface ShippingInfoDetailsOneOf {
    /** Shipment details (when this object describes shipment). */
    shipmentDetails?: ShipmentDetails;
    /** Pickup details (when this object describes pickup). */
    pickupDetails?: PickupDetails;
}
interface ShipmentDetails {
    /** Shipping destination address. */
    address?: Address;
    /**
     * Deprecated (use fulfillments instead).
     * @readonly
     * @deprecated
     */
    trackingInfo?: TrackingInfo;
    /** Discount applied for shipping. */
    discount?: string | null;
    /** Tax applied for shipping. */
    tax?: string | null;
    /** Price data. */
    priceData?: ShippingPriceData;
}
interface TrackingInfo {
    /**
     * Tracking number
     * @readonly
     */
    trackingNumber?: string | null;
    /**
     * Shipping provider
     * @readonly
     */
    shippingProvider?: string | null;
    /**
     * Tracking link
     * @readonly
     */
    trackingLink?: string | null;
}
interface ShippingPriceData {
    /** Whether tax is included in the price. */
    taxIncludedInPrice?: boolean;
    /** Shipping price. */
    price?: string | null;
}
interface PickupDetails {
    /** Pickup address. */
    pickupAddress?: PickupAddress;
    /**
     * Deprecated (use billingInfo instead).
     * @readonly
     * @deprecated
     */
    buyerDetails?: BuyerDetails;
    /** Store owner's pickup instructions. */
    pickupInstructions?: string | null;
}
interface PickupAddress {
    /** Country code (3 letters) */
    country?: string;
    /** State/District */
    subdivision?: string | null;
    /** Address */
    addressLine1?: string;
    /** City */
    city?: string;
    /** ZIP/postal code */
    zipCode?: string;
}
interface BuyerDetails {
    /** Addressee name */
    fullName?: FullName;
    /** Email address */
    email?: string;
    /** Phone number */
    phone?: string;
}
/** This might be extended in the future with pending orders statuses */
declare enum PaymentStatus {
    /** Payment status can't be classified, due to an error */
    UNSPECIFIED_PAYMENT_STATUS = "UNSPECIFIED_PAYMENT_STATUS",
    /** Order is pending response from the payment provider */
    PENDING = "PENDING",
    /** Order is marked as not paid, and can be marked as paid later on. This is relevant for POS and offline orders */
    NOT_PAID = "NOT_PAID",
    /** The order is marked as paid */
    PAID = "PAID",
    /** Order was refunded, refund amount less than order total price */
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    /** Full order total price was refunded */
    FULLY_REFUNDED = "FULLY_REFUNDED",
    /** At least one payment was received and approved, covering less than total price amount */
    PARTIALLY_PAID = "PARTIALLY_PAID"
}
declare enum FulfillmentStatus {
    /** None of the order items are fulfilled */
    NOT_FULFILLED = "NOT_FULFILLED",
    /**
     * All of the order items are fulfilled
     * Orders without shipping info are fulfilled automatically
     */
    FULFILLED = "FULFILLED",
    /** Order is canceled */
    CANCELED = "CANCELED",
    /** Some, but not all of the order items are fulfilled */
    PARTIALLY_FULFILLED = "PARTIALLY_FULFILLED"
}
interface LineItem {
    /**
     * Line item ID (auto-generated, stable within this order only)
     * @readonly
     */
    index?: number | null;
    /** Line item quantity */
    quantity?: number;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    price?: string | null;
    /** Line item name */
    name?: string | null;
    /** Product name, translated into the customer's language */
    translatedName?: string | null;
    /** Line item product ID (optional for POS orders) */
    productId?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    totalPrice?: string | null;
    /** Line item type (may be extended) */
    lineItemType?: LineItemType;
    /** Line item options ordered */
    options?: OptionSelection[];
    /** Line item custom text field entry */
    customTextFields?: CustomTextFieldSelection[];
    /** Line item weight */
    weight?: string | null;
    /** Primary media for preview of the line item */
    mediaItem?: MediaItem;
    /** Line item SKU */
    sku?: string | null;
    /** Line item notes */
    notes?: string | null;
    /** Line item variantId (from Stores Catalog) */
    variantId?: string | null;
    /** Line item fulfillerId from stores fulfillers. No value equals self fulfilled */
    fulfillerId?: string | null;
    /** Discount applied for this line item */
    discount?: string | null;
    /** Tax applied for this line item */
    tax?: string | null;
    /**
     * Deprecated (use priceData instead)
     * @readonly
     * @deprecated
     */
    taxIncludedInPrice?: boolean;
    /** Tax group ID */
    taxGroupId?: string | null;
    /** Price data */
    priceData?: LineItemPriceData;
}
declare enum LineItemType {
    /** Line item type can't be classified, due to an error */
    UNSPECIFIED_LINE_ITEM_TYPE = "UNSPECIFIED_LINE_ITEM_TYPE",
    /** Physical item type */
    PHYSICAL = "PHYSICAL",
    /** Digital item type */
    DIGITAL = "DIGITAL",
    /** Custom item price */
    CUSTOM_AMOUNT_ITEM = "CUSTOM_AMOUNT_ITEM"
}
interface OptionSelection {
    /** Option name */
    option?: string;
    /** Selected choice for this option */
    selection?: string;
}
interface CustomTextFieldSelection {
    /** Custom text field name */
    title?: string;
    /** Custom text field value */
    value?: string;
}
interface MediaItem {
    /**
     * Media type
     * @readonly
     */
    mediaType?: MediaItemType;
    /**
     * Media URL
     * @readonly
     */
    url?: string;
    /**
     * Media item width
     * @readonly
     */
    width?: number;
    /**
     * Media item height
     * @readonly
     */
    height?: number;
    /**
     * Deprecated
     * @deprecated
     */
    mediaId?: string | null;
    /** Media ID (for media items previously saved in Wix Media) */
    _id?: string | null;
    /** Media external URL */
    externalImageUrl?: string | null;
    /** Alternative text for presentation when media cannot be displayed */
    altText?: string | null;
}
declare enum MediaItemType {
    /** Media item type can't be classified, due to an error */
    UNSPECIFIED_MEDIA_TYPE_ITEM = "UNSPECIFIED_MEDIA_TYPE_ITEM",
    /** Image item type */
    IMAGE = "IMAGE"
}
interface LineItemPriceData {
    /** Whether tax is included in the price set for this line item */
    taxIncludedInPrice?: boolean;
    /** Line item price */
    price?: string;
    /**
     * Total price charged to the customer (per line item) after computation of quantity and discount
     * @readonly
     */
    totalPrice?: string | null;
}
interface DigitalFile {
    /** id of the secure file in media */
    fileId?: string;
}
interface Activity {
    /**
     * Activity item type
     * @readonly
     */
    type?: ActivityType;
    /**
     * Activity item author
     * @readonly
     */
    author?: string | null;
    /**
     * Comment added to activity item
     * @readonly
     */
    message?: string | null;
    /**
     * Activity item timestamp
     * @readonly
     */
    timestamp?: Date | null;
}
declare enum ActivityType {
    /** Activity item type can't be classified, due to an error */
    UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE = "UNSPECIFIED_ORDER_HISTORY_ITEM_TYPE",
    /** Store owner added a comment */
    MERCHANT_COMMENT = "MERCHANT_COMMENT",
    /** Order placed */
    ORDER_PLACED = "ORDER_PLACED",
    /** Order marked as paid, either by the store owner (for offline orders), or when an online transaction was confirmed */
    ORDER_PAID = "ORDER_PAID",
    /** Order shipping status set as fulfilled */
    ORDER_FULFILLED = "ORDER_FULFILLED",
    /** Order shipping status set as not fulfilled */
    ORDER_NOT_FULFILLED = "ORDER_NOT_FULFILLED",
    /** A download link was sent (relevant for orders with digital line items) */
    DOWNLOAD_LINK_SENT = "DOWNLOAD_LINK_SENT",
    /** An email notification for pickup was sent */
    PICKUP_READY_EMAIL_SENT = "PICKUP_READY_EMAIL_SENT",
    /** Shipping tracking number was set */
    TRACKING_NUMBER_ADDED = "TRACKING_NUMBER_ADDED",
    /** Shipping tracking number was edited */
    TRACKING_NUMBER_EDITED = "TRACKING_NUMBER_EDITED",
    /** Shipping tracking link was set */
    TRACKING_LINK_WAS_SET = "TRACKING_LINK_WAS_SET",
    /** An email confirmation of order shipment was sent */
    SHIPPING_CONFIRMATION_EMAIL_SENT = "SHIPPING_CONFIRMATION_EMAIL_SENT",
    /** Invoice was set in the order */
    INVOICE_WAS_SET = "INVOICE_WAS_SET",
    /** Invoice was removed from the order */
    INVOICE_WAS_REMOVED = "INVOICE_WAS_REMOVED",
    /** Invoice was sent to customer via email */
    INVOICE_WAS_SENT = "INVOICE_WAS_SENT",
    /** Email was sent to fulfiller */
    FULFILLER_EMAIL_SENT = "FULFILLER_EMAIL_SENT",
    /** Shipping address was updated */
    SHIPPING_ADDRESS_EDITED = "SHIPPING_ADDRESS_EDITED",
    /** Order email was updated */
    EMAIL_EDITED = "EMAIL_EDITED",
    /** Order partially paid. During the checkout for orders with deposit items. */
    ORDER_PARTIALLY_PAID = "ORDER_PARTIALLY_PAID"
}
interface V2InvoiceInfo {
    /** Invoice ID */
    _id?: string;
    /** Invoice source */
    source?: InvoiceSource;
}
declare enum InvoiceSource {
    /** Invoice source can't be classified, due to an error */
    UNSPECIFIED_INVOICE_SOURCE = "UNSPECIFIED_INVOICE_SOURCE",
    /** Invoice created using the Invoices API */
    WIX = "WIX"
}
interface Fulfillment {
    /**
     * Fulfillment ID (auto generated upon fulfillment creation).
     * @readonly
     */
    _id?: string | null;
    /**
     * Fulfillment creation date and time.
     * @readonly
     */
    dateCreated?: Date | null;
    /** Information about the line items in the fulfilled order. */
    lineItems?: FulfillmentLineItem[];
    /** Tracking information. */
    trackingInfo?: FulfillmentTrackingInfo;
}
interface FulfillmentLineItem {
    /** Line item ID (mirrors the line item index of the order). */
    index?: number;
    /**
     * Line item quantity.
     * On creation, if this parameter isn't passed, the new fulfillment will automatically include all items of this line item that have not already been linked to a fulfillment.
     * If the order does not have the requested quantity of line items available to add to this fulfillment, the fulfillment will not be created and an error will be returned.
     * This property will always have a value when returned.
     */
    quantity?: number | null;
}
interface FulfillmentTrackingInfo {
    /** Tracking number. */
    trackingNumber?: string;
    /**
     * Shipping provider. Using the following shipping providers will allow for autofilling the tracking link:
     * * `fedex`
     * * `ups`
     * * `usps`
     * * `dhl`
     * * `canadaPost`
     */
    shippingProvider?: string;
    /** Tracking link - autofilled if using a predefined shipping provider, otherwise provided on creation. */
    trackingLink?: string | null;
}
interface Discount {
    /**
     * Deprecated (use Totals.discount instead)
     * @readonly
     * @deprecated
     */
    value?: string;
    /** Applied coupon */
    appliedCoupon?: AppliedCoupon;
}
interface AppliedCoupon {
    /** Coupon ID */
    couponId?: string;
    /** Coupon name */
    name?: string;
    /** Coupon code */
    code?: string;
}
/** Custom field */
interface CustomField {
    /** Free text that the customer entered in the custom field during the checkout process */
    value?: string;
    /** Title for the custom field */
    title?: string;
    /** The title translated according to the buyer language */
    translatedTitle?: string;
}
interface ChannelInfo {
    /** Sales channel that submitted the order */
    type?: ChannelType;
    /** Reference to an order ID from an external system, as defined in channelInfo (e.g., eBay or Amazon) */
    externalOrderId?: string | null;
    /** URL to the order in the external system, as defined in channelInfo (e.g., eBay or Amazon) */
    externalOrderUrl?: string | null;
}
declare enum ChannelType {
    UNSPECIFIED = "UNSPECIFIED",
    WEB = "WEB",
    POS = "POS",
    EBAY = "EBAY",
    AMAZON = "AMAZON",
    OTHER_PLATFORM = "OTHER_PLATFORM",
    WIX_APP_STORE = "WIX_APP_STORE",
    WIX_INVOICES = "WIX_INVOICES",
    BACKOFFICE_MERCHANT = "BACKOFFICE_MERCHANT",
    WISH = "WISH",
    CLASS_PASS = "CLASS_PASS",
    GLOBAL_E = "GLOBAL_E",
    FACEBOOK = "FACEBOOK",
    ETSY = "ETSY",
    TIKTOK = "TIKTOK",
    FAIRE_COM = "FAIRE_COM"
}
interface EnteredBy {
    _id?: string;
    identityType?: EnteredByIdentityType;
}
declare enum EnteredByIdentityType {
    USER = "USER",
    MEMBER = "MEMBER",
    CONTACT = "CONTACT",
    APP = "APP"
}
interface SubscriptionInfo {
    /** Subscription ID. */
    _id?: string | null;
    /** Current cycle number. For example, if the subscription is in the 3rd month of a 4-month subscription, the value will be `3`. */
    cycleNumber?: number;
    /** Subscription settings. */
    subscriptionSettings?: SubscriptionSettings;
    /** Subscription options info. */
    subscriptionOptionInfo?: SubscriptionOptionInfo;
}
interface SubscriptionSettings {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequency;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`. */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface SubscriptionOptionInfo {
    /** Subscription option title. */
    title?: string;
    /** Subscription option description. */
    description?: string | null;
}
interface V2Refund {
    /** Refund created timestamp. */
    dateCreated?: Date | null;
    /** Refund amount. */
    amount?: string;
    /** Reason for refund, given by user (optional). */
    reason?: string | null;
    /** Payment provider transaction ID. Used to find refund transaction info on the payment provider's side. */
    paymentProviderTransactionId?: string | null;
    /** Refund ID. */
    _id?: string;
    /** Whether refund was made externally (on the payment provider's side). */
    externalRefund?: boolean;
}
interface GiftCard {
    transactionId?: string;
    /**
     * giftcard internal ID
     * @deprecated giftcard internal ID
     * @targetRemovalDate 2024-12-31
     */
    _id?: string;
    /** giftcard provider appid */
    providerId?: string;
    /** giftcard amount */
    amount?: string;
}
/** Triggered when a payment is updated. */
interface PaymentsUpdated {
    /** Updated order transactions. */
    orderTransactions?: OrderTransactions;
    /** List of IDs of the updated payments. */
    paymentIds?: string[];
    /** List of IDs of the updated refunds. */
    refundIds?: string[];
}
interface RefundCompleted {
    /** Order ID. */
    orderId?: string;
    /** Completed refund. */
    refund?: Refund;
    /** Refund side effects. */
    sideEffects?: RefundSideEffects;
    /** Order transactions after refund is completed. */
    orderTransactions?: OrderTransactions;
}
interface RefundSideEffects {
    /** Inventory restock details as part of this refund. */
    restockInfo?: RestockInfo;
    /** Whether to send a refund confirmation email to the customer. */
    sendOrderRefundedEmail?: boolean;
    /** Custom message added to the refund confirmation email. */
    customMessage?: string | null;
}
interface RestockInfo {
    /** Restock type. */
    type?: RestockType;
    /** Restocked line items and quantities. Only relevant for `{"type": "SOME_ITEMS"}`. */
    items?: RestockItem[];
}
declare enum RestockType {
    NO_ITEMS = "NO_ITEMS",
    ALL_ITEMS = "ALL_ITEMS",
    SOME_ITEMS = "SOME_ITEMS"
}
interface RestockItem {
    /** ID of the line item being restocked. */
    lineItemId?: string;
    /** Line item quantity being restocked. */
    quantity?: number;
}
interface ListTransactionsForSingleOrderRequest {
    /** Order ID. */
    orderId: string;
}
interface ListTransactionsForSingleOrderResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
}
interface ListTransactionsForMultipleOrdersRequest {
    /** Order IDs for which to retrieve transactions. */
    orderIds: string[];
}
interface ListTransactionsForMultipleOrdersResponse {
    /** List of order IDs and their associated transactions. */
    orderTransactions?: OrderTransactions[];
}
interface AddPaymentsRequest {
    /** Order ID. */
    orderId: string;
    /** Payments to be added to order. */
    payments: Payment[];
}
interface AddPaymentsResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** IDs of added order payments. */
    paymentsIds?: string[];
}
interface AddRefundRequest {
    /** Order ID this refunds related to */
    orderId?: string;
    /** Refund with refund transactions to be added to order. */
    refund?: Refund;
    /** Side effect details related to refund */
    sideEffects?: RefundSideEffects;
}
interface AddRefundResponse {
    /** Order ID and its associated transactions. */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface UpdatePaymentStatusRequest {
    /** Order ID. */
    orderId: string;
    /** Payment ID. */
    paymentId: string;
    /** Payment status. */
    status?: TransactionStatus;
}
interface UpdatePaymentStatusResponse {
    /** Order ID and its associated transactions after update. */
    orderTransactions?: OrderTransactions;
}
interface BulkUpdatePaymentStatusesRequest {
    /** Order and payment IDs for which to update payment status. */
    paymentAndOrderIds: PaymentAndOrderId[];
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
}
interface PaymentAndOrderId {
    /** Order ID. */
    orderId?: string;
    /**
     * Payment ID.
     * todo: remove comment once UI will use BulkMarkOrderAsPaid
     */
    paymentId?: string;
}
interface BulkUpdatePaymentStatusesResponse {
    /** Bulk operation results. */
    results?: BulkPaymentResult[];
    /** Bulk operation metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkPaymentResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
    /** Updated payment. Returned if `return_full_entity` set to `true`. */
    item?: Payment;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateRefundTransactionRequest {
}
interface UpdateRefundTransactionResponse {
}
interface UpdatePaymentsRequest {
}
interface MaskedPayment {
}
interface UpdatePaymentsResponse {
}
interface QueryOrderTransactionsRequest {
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryOrderTransactionsResponse {
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface TriggerRefundRequest {
    /** The order this refund related to */
    orderId?: string;
    /**
     * Refund operations information
     * Currently, only *one* payment refund is supported per request
     */
    payments?: PaymentRefund[];
    /** Business model of a refund */
    details?: RefundDetails;
    /** How to restock items as part of this refund */
    restockInfo?: RestockInfo;
    /** Should send a confirmation mail to the customer */
    sendOrderRefundedEmail?: boolean;
    /** Personal note added to the email */
    customMessage?: string | null;
}
interface PaymentRefund {
    /** Specific payment within the order to refund */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Whether refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
interface TriggerRefundResponse {
    /** All order's transactions after the refunds were added */
    orderTransactions?: OrderTransactions;
    /** Created refund ID */
    refundId?: string;
}
interface CalculateRefundRequest {
    /** Order ID */
    orderId?: string;
    /** Refunded line items and quantity */
    refundItems?: CalculateRefundItemRequest[];
    /** Should include shipping in refund calculation */
    refundShipping?: boolean;
}
interface CalculateRefundItemRequest {
    /** ID of the line item being refunded */
    lineItemId?: string;
    /** How much of that line item is being refunded */
    quantity?: number;
    /** Should this item be restocked (used for validation purposes) */
    restock?: boolean;
}
interface CalculateRefundResponse {
    /** Total refundable amount */
    total?: string;
    /** Tax cost of the order */
    tax?: string;
    /** Discount given for this order */
    discount?: string;
    /** Total cost of the order (without tax) */
    subtotal?: string;
    /** Previous refund given on that order */
    previouslyRefundedAmount?: string | null;
    /** The refundable items of that order */
    items?: CalculateRefundItemResponse[];
}
interface CalculateRefundItemResponse {
    /** Line item ID */
    lineItemId?: string;
    /** The line item's price */
    lineItemPrice?: number;
}
interface GetRefundabilityStatusRequest {
    /** Order ID. */
    orderId?: string;
}
interface GetRefundabilityStatusResponse {
    /** Refundability details. */
    refundabilities?: Refundability[];
    /** Whether the order supports refunding per item. */
    refundablePerItem?: boolean;
}
interface Refundability extends RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReason;
    /** Payment ID. */
    paymentId?: string;
    /** Payment refundability status. */
    refundabilityStatus?: RefundableStatus;
    /** Link to payment provider dashboard. */
    providerLink?: string | null;
}
/** @oneof */
interface RefundabilityAdditionalRefundabilityInfoOneOf {
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
    /** Reason why payment is only refundable manually. */
    manuallyRefundableReason?: ManuallyRefundableReason;
}
declare enum RefundableStatus {
    NOT_REFUNDABLE = "NOT_REFUNDABLE",
    MANUAL = "MANUAL",
    REFUNDABLE = "REFUNDABLE"
}
declare enum NonRefundableReason {
    NONE = "NONE",
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    INTERNAL_ERROR = "INTERNAL_ERROR",
    NOT_PAID = "NOT_PAID",
    ACCESS_DENIED = "ACCESS_DENIED",
    ZERO_PRICE = "ZERO_PRICE",
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    PARTIALLY_PAID = "PARTIALLY_PAID",
    DEPOSIT_ONLINE_ITEM = "DEPOSIT_ONLINE_ITEM",
    PENDING_REFUND = "PENDING_REFUND",
    FORBIDDEN = "FORBIDDEN"
}
declare enum ManuallyRefundableReason {
    EXPIRED = "EXPIRED",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    NOT_FOUND = "NOT_FOUND",
    OFFLINE = "OFFLINE"
}
interface ListInvoicesForSingleOrderRequest {
    /** Order ID. */
    orderId?: string;
}
interface ListInvoicesForSingleOrderResponse {
    /** List of invoices. */
    invoices?: InvoiceInfo[];
}
interface InvoiceInfo {
    /** Invoice ID. */
    _id?: string;
    /** ID of the app that set the invoice. */
    appId?: string;
    /**
     * Invoice URL.
     * @deprecated
     */
    url?: string | null;
    /**
     * Invoice creation date and time.
     * @deprecated
     */
    _createdDate?: Date | null;
}
interface ListInvoicesForMultipleOrdersRequest {
    /** Order IDs for which to retrieve invoices. */
    orderIds?: string[];
}
interface ListInvoicesForMultipleOrdersResponse {
    /** List of order IDs and their associated invoices. */
    invoicesForOrder?: InvoicesForOrder[];
}
interface InvoicesForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoices info. */
    invoicesInfo?: InvoiceInfo[];
}
interface GenerateInvoiceRequest {
    /** Order ID. */
    orderId?: string;
}
interface GenerateInvoiceResponse {
    /** Invoice ID. */
    invoiceId?: string;
}
interface BulkGenerateInvoicesRequest {
    /** Order IDs. */
    orderIds?: string[];
}
interface BulkGenerateInvoicesResponse {
    results?: BulkInvoiceResult[];
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInvoiceResult {
    itemMetadata?: ItemMetadata;
    item?: InvoiceForOrder;
}
interface InvoiceForOrder {
    /** Order ID. */
    orderId?: string;
    /** Invoice ID. */
    invoiceId?: string;
}
interface AddInvoiceToOrderRequest {
    /** Order ID. */
    orderId?: string;
    /** Invoice info. */
    invoiceInfo?: InvoiceInfo;
}
interface AddInvoiceToOrderResponse {
    /** List of order invoices. */
    orderInvoices?: InvoiceInfo[];
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface PriceNonNullableFields {
    amount: string;
    formattedAmount: string;
}
interface AuthorizationActionFailureDetailsNonNullableFields {
    failureCode: string;
}
interface AuthorizationCaptureNonNullableFields {
    status: AuthorizationCaptureStatus;
    amount?: PriceNonNullableFields;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
}
interface AuthorizationVoidNonNullableFields {
    status: AuthorizationVoidStatus;
    failureDetails?: AuthorizationActionFailureDetailsNonNullableFields;
    reason: Reason;
}
interface ScheduledActionNonNullableFields {
    actionType: ActionType;
}
interface AuthorizationDetailsNonNullableFields {
    delayedCapture: boolean;
    captures: AuthorizationCaptureNonNullableFields[];
    void?: AuthorizationVoidNonNullableFields;
    scheduledAction?: ScheduledActionNonNullableFields;
}
interface RegularPaymentDetailsNonNullableFields {
    offlinePayment: boolean;
    status: TransactionStatus;
    savedPaymentMethod: boolean;
    authorizationDetails?: AuthorizationDetailsNonNullableFields;
}
interface GiftCardPaymentDetailsNonNullableFields {
    giftCardPaymentId: string;
    giftCardId: string;
    appId: string;
    voided: boolean;
}
interface MembershipNameNonNullableFields {
    original: string;
}
interface MembershipPaymentDetailsNonNullableFields {
    membershipId: string;
    lineItemId: string;
    status: MembershipPaymentStatus;
    name?: MembershipNameNonNullableFields;
    voided: boolean;
    providerAppId: string;
}
interface PaymentNonNullableFields {
    regularPaymentDetails?: RegularPaymentDetailsNonNullableFields;
    giftcardPaymentDetails?: GiftCardPaymentDetailsNonNullableFields;
    membershipPaymentDetails?: MembershipPaymentDetailsNonNullableFields;
    amount?: PriceNonNullableFields;
    refundDisabled: boolean;
}
interface RefundTransactionNonNullableFields {
    paymentId: string;
    amount?: PriceNonNullableFields;
    refundStatus: RefundStatus;
    externalRefund: boolean;
}
interface RefundItemNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface LineItemRefundNonNullableFields {
    lineItemId: string;
    quantity: number;
}
interface AdditionalFeeRefundNonNullableFields {
    additionalFeeId: string;
    amount?: PriceNonNullableFields;
}
interface ShippingRefundNonNullableFields {
    amount?: PriceNonNullableFields;
}
interface RefundDetailsNonNullableFields {
    items: RefundItemNonNullableFields[];
    shippingIncluded: boolean;
    lineItems: LineItemRefundNonNullableFields[];
    additionalFees: AdditionalFeeRefundNonNullableFields[];
    shipping?: ShippingRefundNonNullableFields;
}
interface AggregatedRefundSummaryNonNullableFields {
    requestedRefund?: PriceNonNullableFields;
    pendingRefund?: PriceNonNullableFields;
    refunded?: PriceNonNullableFields;
    failedRefundAmount?: PriceNonNullableFields;
    pending: boolean;
}
interface RefundNonNullableFields {
    _id: string;
    transactions: RefundTransactionNonNullableFields[];
    details?: RefundDetailsNonNullableFields;
    summary?: AggregatedRefundSummaryNonNullableFields;
}
interface OrderTransactionsNonNullableFields {
    orderId: string;
    payments: PaymentNonNullableFields[];
    refunds: RefundNonNullableFields[];
}
interface ListTransactionsForSingleOrderResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
interface ListTransactionsForMultipleOrdersResponseNonNullableFields {
    orderTransactions: OrderTransactionsNonNullableFields[];
}
interface AddPaymentsResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
    paymentsIds: string[];
}
interface UpdatePaymentStatusResponseNonNullableFields {
    orderTransactions?: OrderTransactionsNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkPaymentResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: PaymentNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkUpdatePaymentStatusesResponseNonNullableFields {
    results: BulkPaymentResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface UpdatePaymentStatusIdentifiers {
    /** Payment ID. */
    paymentId: string;
    /** Order ID. */
    orderId: string;
}
interface UpdatePaymentStatusOptions {
    /** Payment status. */
    status?: TransactionStatus;
}
interface BulkUpdatePaymentStatusesOptions {
    /** Whether to return the full payment entity (`results.item`) in the response. */
    returnFullEntity?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
}

declare function listTransactionsForSingleOrder$1(httpClient: HttpClient): ListTransactionsForSingleOrderSignature;
interface ListTransactionsForSingleOrderSignature {
    /**
     * Retrieves information about payments and refunds associated with a specified order.
     *
     *
     * The `listTransactionsForSingleOrder()` function returns a Promise that resolves when the specified order's transaction records are retrieved.
     * @param - Order ID.
     */
    (orderId: string): Promise<ListTransactionsForSingleOrderResponse & ListTransactionsForSingleOrderResponseNonNullableFields>;
}
declare function listTransactionsForMultipleOrders$1(httpClient: HttpClient): ListTransactionsForMultipleOrdersSignature;
interface ListTransactionsForMultipleOrdersSignature {
    /**
     * Retrieves information about payments and refunds associated with all specified orders.
     *
     *
     * The `listTransactionsForMultipleOrders()` function returns a Promise that resolves when the specified orders' transaction records are retrieved.
     * @param - Order IDs for which to retrieve transactions.
     */
    (orderIds: string[]): Promise<ListTransactionsForMultipleOrdersResponse & ListTransactionsForMultipleOrdersResponseNonNullableFields>;
}
declare function addPayments$1(httpClient: HttpClient): AddPaymentsSignature;
interface AddPaymentsSignature {
    /**
     * Adds up to 50 payment records to an order.
     *
     *
     * The `addPayments()` function returns a Promise that resolves when the payment records are added to an order.
     *
     * > **Note:** This does **NOT** perform the actual charging - the order is only updated with records of the payments.
     * @param - Order ID.
     * @param - Payments to be added to order.
     */
    (orderId: string, payments: Payment[]): Promise<AddPaymentsResponse & AddPaymentsResponseNonNullableFields>;
}
declare function updatePaymentStatus$1(httpClient: HttpClient): UpdatePaymentStatusSignature;
interface UpdatePaymentStatusSignature {
    /**
     * Updates the status of an order's payment.
     *
     *
     * The `updatePaymentStatus()` function returns a Promise that resolves when the payment status is updated.
     */
    (identifiers: UpdatePaymentStatusIdentifiers, options?: UpdatePaymentStatusOptions | undefined): Promise<UpdatePaymentStatusResponse & UpdatePaymentStatusResponseNonNullableFields>;
}
declare function bulkUpdatePaymentStatuses$1(httpClient: HttpClient): BulkUpdatePaymentStatusesSignature;
interface BulkUpdatePaymentStatusesSignature {
    /**
     * Updates multiple order payments with a specified status.
     *
     *
     * The `bulkUpdatePaymentStatus()` function returns a Promise that resolves when the payment statuses are updated.
     * @param - Order and payment IDs for which to update payment status.
     */
    (paymentAndOrderIds: PaymentAndOrderId[], options?: BulkUpdatePaymentStatusesOptions | undefined): Promise<BulkUpdatePaymentStatusesResponse & BulkUpdatePaymentStatusesResponseNonNullableFields>;
}

declare const listTransactionsForSingleOrder: MaybeContext<BuildRESTFunction<typeof listTransactionsForSingleOrder$1> & typeof listTransactionsForSingleOrder$1>;
declare const listTransactionsForMultipleOrders: MaybeContext<BuildRESTFunction<typeof listTransactionsForMultipleOrders$1> & typeof listTransactionsForMultipleOrders$1>;
declare const addPayments: MaybeContext<BuildRESTFunction<typeof addPayments$1> & typeof addPayments$1>;
declare const updatePaymentStatus: MaybeContext<BuildRESTFunction<typeof updatePaymentStatus$1> & typeof updatePaymentStatus$1>;
declare const bulkUpdatePaymentStatuses: MaybeContext<BuildRESTFunction<typeof bulkUpdatePaymentStatuses$1> & typeof bulkUpdatePaymentStatuses$1>;

export { type ActionEvent, ActionType, type Activity, ActivityType, type AddInvoiceToOrderRequest, type AddInvoiceToOrderResponse, type AddPaymentsRequest, type AddPaymentsResponse, type AddPaymentsResponseNonNullableFields, type AddRefundRequest, type AddRefundResponse, type AdditionalFeeRefund, type Address, type AddressAddressLine1OptionsOneOf, type AggregatedRefundSummary, type ApplicationError, type AppliedCoupon, type AuthorizationActionFailureDetails, type AuthorizationCapture, AuthorizationCaptureStatus, type AuthorizationDetails, type AuthorizationVoid, AuthorizationVoidStatus, type BillingInfo, type BulkActionMetadata, type BulkGenerateInvoicesRequest, type BulkGenerateInvoicesResponse, type BulkInvoiceResult, type BulkPaymentResult, type BulkUpdatePaymentStatusesOptions, type BulkUpdatePaymentStatusesRequest, type BulkUpdatePaymentStatusesResponse, type BulkUpdatePaymentStatusesResponseNonNullableFields, type BuyerDetails, type BuyerInfo, type CalculateRefundItemRequest, type CalculateRefundItemResponse, type CalculateRefundRequest, type CalculateRefundResponse, type ChannelInfo, ChannelType, type CreditCardPaymentMethodDetails, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type CustomField, type CustomTextFieldSelection, type DiffmatokyPayload, type DigitalFile, type Discount, type DomainEvent, type DomainEventBodyOneOf, type EnteredBy, EnteredByIdentityType, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type ErrorInformation, type Fulfillment, type FulfillmentLineItem, FulfillmentStatus, type FulfillmentTrackingInfo, type FullName, type GenerateInvoiceRequest, type GenerateInvoiceResponse, type GetRefundabilityStatusRequest, type GetRefundabilityStatusResponse, type GiftCard, type GiftCardPaymentDetails, type IdentificationData, type IdentificationDataIdOneOf, IdentityType, type IndexingMessage, type InvoiceForOrder, type InvoiceInfo, InvoiceSource, type InvoicesForOrder, type ItemMetadata, type LineItem, type LineItemPriceData, type LineItemRefund, LineItemType, type ListInvoicesForMultipleOrdersRequest, type ListInvoicesForMultipleOrdersResponse, type ListInvoicesForSingleOrderRequest, type ListInvoicesForSingleOrderResponse, type ListTransactionsForMultipleOrdersRequest, type ListTransactionsForMultipleOrdersResponse, type ListTransactionsForMultipleOrdersResponseNonNullableFields, type ListTransactionsForSingleOrderRequest, type ListTransactionsForSingleOrderResponse, type ListTransactionsForSingleOrderResponseNonNullableFields, ManuallyRefundableReason, type MaskedPayment, type MediaItem, MediaItemType, type MembershipName, type MembershipPaymentDetails, MembershipPaymentStatus, type MessageEnvelope, NonRefundableReason, type OptionSelection, type Order, type OrderRefunded, type OrderTransactions, type Payment, type PaymentAndOrderId, type PaymentPaymentDetailsOneOf, type PaymentRefund, PaymentStatus, type PaymentsUpdated, type PickupAddress, type PickupDetails, type Price, type QueryOrderTransactionsRequest, type QueryOrderTransactionsResponse, Reason, type Refund, type RefundCompleted, type RefundDetails, type RefundItem, type RefundSideEffects, RefundStatus, type RefundTransaction, type Refundability, type RefundabilityAdditionalRefundabilityInfoOneOf, RefundableStatus, type RegularPaymentDetails, type RegularPaymentDetailsPaymentMethodDetailsOneOf, type RestockInfo, type RestockItem, RestockType, type RestoreInfo, type ScheduledAction, type ShipmentDetails, type ShippingInfo, type ShippingInfoDetailsOneOf, type ShippingPriceData, type ShippingRefund, type SnapshotMessage, SortOrder, type Sorting, type Street, SubscriptionFrequency, type SubscriptionInfo, type SubscriptionOptionInfo, type SubscriptionSettings, type Totals, type TrackingInfo, TransactionStatus, type TriggerRefundRequest, type TriggerRefundResponse, type UpdatePaymentStatusIdentifiers, type UpdatePaymentStatusOptions, type UpdatePaymentStatusRequest, type UpdatePaymentStatusResponse, type UpdatePaymentStatusResponseNonNullableFields, type UpdatePaymentsRequest, type UpdatePaymentsResponse, type UpdateRefundTransactionRequest, type UpdateRefundTransactionResponse, type V2InvoiceInfo, type V2Refund, type VatId, VatType, WebhookIdentityType, WeightUnit, addPayments, bulkUpdatePaymentStatuses, listTransactionsForMultipleOrders, listTransactionsForSingleOrder, updatePaymentStatus };
